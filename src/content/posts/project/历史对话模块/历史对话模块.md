---
title: 历史对话模块
published: 2026-01-14
description: ''
image: '../cover.png'
tags: ["project"]
category: 'project'
draft: false 
lang: ''
---
# 一、需求分析
我们实现了 AI 生成应用的核心功能，但存在一个明显的问题：**每次对话都是独立的，AI 无法记住之前的交互内容**。这导致用户无法基于已生成的网站进行迭代改进，极大地限制了平台的实用性。

**举个例子**：用户首先让‍‍‍‍ AI 生成一个博客网站，然后希望在此基⁡⁡⁡⁡础上添加评论功能，最后再优化一下页面‏‏‏‏样式。在没有对话记忆的情况下，每次都需要重新؜؜؜؜描述完整需求，AI 也会重新生成整个网站﻿﻿﻿﻿，而不是在原有基础上进行改进。

因此，我们需要实现以下需求：

- 1）**对话历史的‍‍‍‍持久化存储**：用户发送消息时，⁡⁡⁡⁡需要保存用户消息；AI 成功‏‏‏‏回复后，需要保存 AI 消؜؜息؜؜。即使 AI 回复失败，也要﻿﻿﻿﻿记录错误信息，确保对话的完整性。


- 2）**应用级‍‍‍‍别的数据隔离**：每个应⁡⁡⁡⁡用的对话历史都是独‏‏‏‏立的。删除应用时，需要؜؜؜؜关联删除该应用的所有﻿﻿﻿﻿对话历史，避免数据冗余。


- 3）**对话历史查询**：支持分页查看某个应用的对话历史，需要区分用户和 AI 消息。类似聊天软件的消息加载机制，每次加载最新 10 条消息，支持 向前加载 更多历史记录。（仅应用创建者和管理员可见）

详细来说，进入应用页面‍‍‍‍时，前端根据应用 id 先加载一次对话历史⁡⁡⁡⁡消息，关联查询最新 10 条消息。如果存在‏‏‏‏历史对话，直接展示；如果没有历史记录，才自؜؜؜؜动发送初始化提示词。这样就解决了之前浏览别﻿﻿﻿﻿人的应用时意外触发对话的问题。

- 4）管理对话历‍‍‍‍史：管理员可以查看所有应用⁡⁡⁡⁡的对话历史，按照时间降序排‏‏‏‏序，便于内容监管。    ؜؜؜؜    

# 二、方案设计
## 1、核心设计
根据我们的方案，可以设计出对话历史表的结构：
````
-- 对话历史表
create table chat_history
(
    id          bigint auto_increment comment 'id' primary key,
    message     text                               not null comment '消息',
    messageType varchar(32)                        not null comment 'user/ai',
    appId       bigint                             not null comment '应用id',
    userId      bigint                             not null comment '创建用户id',
    createTime  datetime default CURRENT_TIMESTAMP not null comment '创建时间',
    updateTime  datetime default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment '更新时间',
    isDelete    tinyint  default 0                 not null comment '是否删除',
    INDEX idx_appId (appId),                       -- 提升基于应用的查询性能
    INDEX idx_createTime (createTime),             -- 提升基于时间的查询性能
    INDEX idx_appId_createTime (appId, createTime) -- 游标查询核心索引
) comment '对话历史' collate = utf8mb4_unicode_ci;
````

# 三、对话历史后端开发

## 核心功能实现
### 1、新增对话历史
对话历史的保存需要在 用户发送消息 和 AI 回复完成 这两个时机进行。无论 AI 回复成功还是失败，都要留下完整的对话记录，确保用户能够了解完整的交互历史。

可以在 ChatHistoryServiceImpl 中提供统一的保存接口：
````
@Override
public boolean addChatMessage(Long appId, String message, String messageType, Long userId) {
    ThrowUtils.throwIf(appId == null || appId <= 0, ErrorCode.PARAMS_ERROR, "应用ID不能为空");
    ThrowUtils.throwIf(StrUtil.isBlank(message), ErrorCode.PARAMS_ERROR, "消息内容不能为空");
    ThrowUtils.throwIf(StrUtil.isBlank(messageType), ErrorCode.PARAMS_ERROR, "消息类型不能为空");
    ThrowUtils.throwIf(userId == null || userId <= 0, ErrorCode.PARAMS_ERROR, "用户ID不能为空");
    // 验证消息类型是否有效
    ChatHistoryMessageTypeEnum messageTypeEnum = ChatHistoryMessageTypeEnum.getEnumByValue(messageType);
    ThrowUtils.throwIf(messageTypeEnum == null, ErrorCode.PARAMS_ERROR, "不支持的消息类型: " + messageType);
    ChatHistory chatHistory = ChatHistory.builder()
            .appId(appId)
            .message(message)
            .messageType(messageType)
            .userId(userId)
            .build();
    return this.save(chatHistory);
}
````
然后在 AppServiceImpl 的 chatToGenCode 方法中集成对话历史保存逻辑。这里利用了 Flux 响应式编程的特性，可以在流式响应的过程中收集完整的 AI 回复：
````
@Resource
private ChatHistoryService chatHistoryService;

@Override
public Flux<String> chatToGenCode(Long appId, String message, User loginUser) {
    // ... 前面省略
    // 4. 获取应用的代码生成类型
    String codeGenTypeStr = app.getCodeGenType();
    CodeGenTypeEnum codeGenTypeEnum = CodeGenTypeEnum.getEnumByValue(codeGenTypeStr);
    if (codeGenTypeEnum == null) {
        throw new BusinessException(ErrorCode.SYSTEM_ERROR, "不支持的代码生成类型");
    }
    // 5. 通过校验后，添加用户消息到对话历史
    chatHistoryService.addChatMessage(appId, message, ChatHistoryMessageTypeEnum.USER.getValue(), loginUser.getId());
    // 6. 调用 AI 生成代码（流式）
    Flux<String> contentFlux = aiCodeGeneratorFacade.generateAndSaveCodeStream(message, codeGenTypeEnum, appId);
    // 7. 收集AI响应内容并在完成后记录到对话历史
    StringBuilder aiResponseBuilder = new StringBuilder();
    return contentFlux
            .map(chunk -> {
                // 收集AI响应内容
                aiResponseBuilder.append(chunk);
                return chunk;
            })
            .doOnComplete(() -> {
                // 流式响应完成后，添加AI消息到对话历史
                String aiResponse = aiResponseBuilder.toString();
                if (StrUtil.isNotBlank(aiResponse)) {
                    chatHistoryService.addChatMessage(appId, aiResponse, ChatHistoryMessageTypeEnum.AI.getValue(), loginUser.getId());
                }
            })
            .doOnError(error -> {
                // 如果AI回复失败，也要记录错误消息
                String errorMessage = "AI回复失败: " + error.getMessage();
                chatHistoryService.addChatMessage(appId, errorMessage, ChatHistoryMessageTypeEnum.AI.getValue(), loginUser.getId());
            });
}
````
### 2、关联删除
当应用被删除时，需要同步清理对话历史数据。

## 3、分页查询某个应用的对话历史（游标查询）
````
/**
 * 获取查询包装类
 *
 * @param chatHistoryQueryRequest
 * @return
 */
@Override
public QueryWrapper getQueryWrapper(ChatHistoryQueryRequest chatHistoryQueryRequest) {
    QueryWrapper queryWrapper = QueryWrapper.create();
    if (chatHistoryQueryRequest == null) {
        return queryWrapper;
    }
    Long id = chatHistoryQueryRequest.getId();
    String message = chatHistoryQueryRequest.getMessage();
    String messageType = chatHistoryQueryRequest.getMessageType();
    Long appId = chatHistoryQueryRequest.getAppId();
    Long userId = chatHistoryQueryRequest.getUserId();
    LocalDateTime lastCreateTime = chatHistoryQueryRequest.getLastCreateTime();
    String sortField = chatHistoryQueryRequest.getSortField();
    String sortOrder = chatHistoryQueryRequest.getSortOrder();
    // 拼接查询条件
    queryWrapper.eq("id", id)
            .like("message", message)
            .eq("messageType", messageType)
            .eq("appId", appId)
            .eq("userId", userId);
    // 游标查询逻辑 - 只使用 createTime 作为游标
    if (lastCreateTime != null) {
        queryWrapper.lt("createTime", lastCreateTime);
    }
    // 排序
    if (StrUtil.isNotBlank(sortField)) {
        queryWrapper.orderBy(sortField, "ascend".equals(sortOrder));
    } else {
        // 默认按创建时间降序排列
        queryWrapper.orderBy("createTime", false);
    }
    return queryWrapper;
}
````

开发游标查询接口：
````
/**
 * 分页查询某个应用的对话历史（游标查询）
 *
 * @param appId          应用ID
 * @param pageSize       页面大小
 * @param lastCreateTime 最后一条记录的创建时间
 * @param request        请求
 * @return 对话历史分页
 */
@GetMapping("/app/{appId}")
public BaseResponse<Page<ChatHistory>> listAppChatHistory(@PathVariable Long appId,
                                                          @RequestParam(defaultValue = "10") int pageSize,
                                                          @RequestParam(required = false) LocalDateTime lastCreateTime,
                                                          HttpServletRequest request) {
    User loginUser = userService.getLoginUser(request);
    Page<ChatHistory> result = chatHistoryService.listAppChatHistoryByPage(appId, pageSize, lastCreateTime, loginUser);
    return ResultUtils.success(result);
}
````

# 四、对话记‍‍‍‍忆

## 需求分析
很多时候 AI‍‍ 生‍‍‍成的网站没办法一次性满⁡⁡足用户的需求，因⁡⁡⁡此需要提供‏‏网站修改功能。      ؜‏‏‏؜             ﻿﻿     ؜؜؜                     ﻿﻿﻿                   

但是目前我们‍‍‍‍‍的 AI 对话会断片儿⁡⁡⁡⁡⁡，无法记住之前的对话内‏‏‏‏‏容，每次修改实际上都是؜؜؜؜؜重新生成完整的网站，而﻿﻿﻿﻿﻿不是在原有基础上进行修改。

## 方案设计
要解决这个‍‍‍‍问题，就要给 AI ⁡⁡⁡⁡增加对话记忆能力。

## 保存到哪儿？
LangC‍‍‍‍‍hain4j 不⁡⁡⁡⁡仅⁡提供了对话记忆‏‏‏‏能力‏，而且还能结؜؜؜؜合 R؜edis ﻿﻿﻿﻿持久化对﻿话记忆

### 这里有两个2 个问题：

1）为什么不直接用内存来存储会话记忆？

- 首先是重启‍‍‍‍‍后会丢失记忆
- 其⁡⁡⁡⁡次⁡如果每个应用都‏‏‏‏在内‏存中维护对话؜؜؜؜历史，؜很容易出现﻿﻿﻿﻿ OO﻿M 问题。

2）为什么不用 MySQL 来存储会话记忆？

- 一方面是因为 R‍‍‍‍‍edis 作为内存数据库，在读写⁡⁡⁡⁡⁡对话记忆时性能更高；
- 另一方面是数‏‏‏‏‏据库中的对话历史表包含其他业务字؜؜؜؜؜段，不适合直接交给 LangCh﻿﻿﻿﻿﻿ain4j 的对话记忆组件管理。

### 加载历史
要注意，Redis 的内存也不是无限的！ 一般情况下要给存入 Redis 的每个 Key 都设置合理的过期时间，不能不过期。所以这就可能导致 Redis 的会话记忆被删除的情况。

方案很简单，之‍‍‍‍‍前我们已经在数据库中保存了用⁡⁡⁡⁡⁡户和 AI 的消息，只需要在‏‏‏‏‏初始化会话记忆时，加载最新的؜؜؜؜؜对话记录到 Redis 中，﻿﻿﻿﻿﻿就能确保 AI 了解交互历史。

**流程**：AI‍‍‍‍‍ 对话 => 从数⁡⁡⁡⁡⁡据库中加载对话历史‏‏‏‏‏到 Redis =؜؜؜؜؜> Redis 为﻿﻿﻿﻿﻿ AI 提供对话记忆

### 对话隔离
此外，每个‍‍‍‍‍应用的对话记忆应该是⁡⁡⁡⁡⁡相互隔离的，Lang‏‏‏‏‏Chain4j 也提؜؜؜؜؜供了对话记忆隔离的能﻿﻿﻿﻿﻿力。、

## 开发实现
### 1、引入依赖
参考 [LangChain4j 官方文档](https://docs.langchain4j.dev/integrations/embedding-stores/redis/)，引入必要的依赖：
````
<dependency>
  <groupId>dev.langchain4j</groupId>
  <artifactId>langchain4j-community-redis-spring-boot-starter</artifactId>
  <version>1.1.0-beta7</version>
</dependency>
````
这个依赖会‍‍‍‍‍引入 Redis⁡⁡⁡⁡ ⁡的 Jedis‏‏‏‏ 客‏户端，以及与؜؜؜؜ La؜ngCha﻿﻿﻿﻿in4j 的﻿整合组件。

### 2、配置 Redis
1）在配置文件中添加 Redis 连接信息：
````
spring:
  # redis
  data:
    redis:
      host: localhost
      port: 6379
      password: 
      ttl: 3600
````

注意，这里的 ttl 不是连接 Redis 的超时时间（timeout），而是过期时间（单位：秒），我这里设置 1 小时。前面也提到，如果消息数比较多，不设置的话 Redis 内存很容易占满。

2）在 config 下新建 Redis 对话记忆存储配置类，初始化 RedisChatMemoryStore 的 Bean：
````
@Configuration
@ConfigurationProperties(prefix = "spring.data.redis")
@Data
public class RedisChatMemoryStoreConfig {

    private String host;

    private int port;

    private String password;

    private long ttl;

    @Bean
    public RedisChatMemoryStore redisChatMemoryStore() {
        return RedisChatMemoryStore.builder()
                .host(host)
                .port(port)
                .password(password)
                .ttl(ttl)
                .build();
    }
}
````
注意，如果‍Redis密码不为空‏‏‏，上‏述配‏置中还؜؜؜要添加؜ us؜e﻿﻿﻿r 用户﻿名配置：

3）在启动‍‍‍‍‍类中排除 ⁡e⁡m⁡b⁡e⁡d‏di‏ng‏ 的‏؜自动‏؜装配，؜因﻿为本؜项﻿目用؜不﻿到：
````
@SpringBootApplication(exclude = {RedisEmbeddingStoreAutoConfiguration.class})
````
### 3、使用对话记忆
不同 ap‍‍‍‍‍pId 的对话记⁡⁡⁡⁡忆⁡是独立隔离的，‏‏‏‏利用‏ LangC؜؜؜؜hai؜n4j 可﻿﻿﻿﻿以有 2 种﻿实现方案。

#### 方案 1 - 内置隔离机制
参考 [官方文档](https://docs.langchain4j.dev/tutorials/ai-services/#chat-memory)，可以给 AI 服务方法增加 memoryId 注解和参数，然后通过 chatMemoryProvider 为每个 appId 分配对话记忆。

由于我们目‍‍‍‍‍前使用的是同一⁡⁡⁡个⁡ ⁡AiSer‏‏‏vi‏ce‏ 实例؜؜؜，先采؜用这种؜方﻿﻿﻿式，好像﻿修改﻿成本更低。

修改 AiService 方法：
````
interface AiCodeGeneratorService  {
    HtmlCodeResult generateHtmlCode(@MemoryId int memoryId, @UserMessage String userMessage);
}
````
在工厂类中创建 AI Service 时，我们必须通过 chatMemoryProvider 为每个 memoryId 来构造专属的 MessageWindowChatMemory。注意，必须为 MessageWindowChatMemory 设置 id，因为使用的是同一个 Redis 存储实例，否则 Redis 中的存储 key 都是 default，无法区分不同的对话。
````
private final RedisChatMemoryStore redisChatMemoryStore;

@Bean
public AiCodeGeneratorService aiCodeGeneratorService() {
    return AiServices.builder(AiCodeGeneratorService.class)
            .chatModel(chatModel)
            .streamingChatModel(streamingChatModel)
            // 根据 id 构建独立的对话记忆
            .chatMemoryProvider(memoryId -> MessageWindowChatMemory
                    .builder()
                    .id(memoryId)
                    .chatMemoryStore(redisChatMemoryStore)
                    .maxMessages(20)
                    .build())
            .build();
}
````
现在调用 AI 生成方法时，要多传一个 id 参数：
````
generateHtmlCode(1, "生成博客网站");
generateHtmlCode(2, "生成电商网站");
````

#### 方案 2 - AI Service 隔离
之前所有应用共用‍‍‍‍‍同一个 AI Service 实⁡⁡⁡⁡⁡例，如果想隔离会话记忆，可以给每‏‏‏‏‏个应用分配一个专属的 AI Se؜؜؜؜؜rvice，每个 AI Serv﻿﻿﻿﻿﻿ice 绑定独立的对话记忆。

修改 AI‍‍‍‍‍ Service⁡⁡⁡⁡ ⁡工厂类，提供根‏‏‏‏据 ‏appId ؜؜؜؜获取 ؜AI Se﻿﻿﻿﻿rvic﻿e 服务的方法：

````
@Configuration
public class AiCodeGeneratorServiceFactory {

    @Resource
    private ChatModel chatModel;

    @Resource
    private StreamingChatModel streamingChatModel;

    @Resource
    private RedisChatMemoryStore redisChatMemoryStore;

    /**
     * 根据 appId 获取服务
     */
    public AiCodeGeneratorService getAiCodeGeneratorService(long appId) {
        // 根据 appId 构建独立的对话记忆
        MessageWindowChatMemory chatMemory = MessageWindowChatMemory
                .builder()
                .id(appId)
                .chatMemoryStore(redisChatMemoryStore)
                .maxMessages(20)
                .build();
        return AiServices.builder(AiCodeGeneratorService.class)
                .chatModel(chatModel)
                .streamingChatModel(streamingChatModel)
                .chatMemory(chatMemory)
                .build();
    }
}
````
为了保证跟‍‍‍‍‍之前的代码兼⁡⁡容⁡，⁡仍⁡然默认‏‏提供‏一个‏ A‏؜؜I S؜erv؜i﻿﻿ce؜ ﻿的 Be﻿an：
````
/**
 * 默认提供一个 Bean
 */
@Bean
public AiCodeGeneratorService aiCodeGeneratorService() {
    return getAiCodeGeneratorService(0L);
}
````
### 4、本地缓存优化
基于方案 2，我们可以利用[Caffeine](https://github.com/ben-manes/caffeine) 本地缓存 进一步优化性能。

每次构造完 appId‍‍‍‍‍ 对应的 AI 服务实例后，利用 Caff⁡⁡⁡⁡⁡eine 缓存来存储，之后相同 appId‏‏‏‏‏ 就能直接获取到 AI 服务实例，避免重؜؜؜؜؜复构造。注意，本地缓存占用的是内存，所以必须﻿﻿﻿﻿﻿设置合理的过期策略防止内存泄漏。

先引入 Caffeine 依赖：
````
<dependency>
    <groupId>com.github.ben-manes.caffeine</groupId>
    <artifactId>caffeine</artifactId>
</dependency>
````
优化 AiCo‍‍‍‍‍deGeneratorSe⁡⁡⁡⁡⁡rviceFactory，‏‏‏‏‏增加缓存逻辑：
````
/**
 * AI 服务实例缓存
 * 缓存策略：
 * - 最大缓存 1000 个实例
 * - 写入后 30 分钟过期
 * - 访问后 10 分钟过期
 */
private final Cache<Long, AiCodeGeneratorService> serviceCache = Caffeine.newBuilder()
        .maximumSize(1000)
        .expireAfterWrite(Duration.ofMinutes(30))
        .expireAfterAccess(Duration.ofMinutes(10))
        .removalListener((key, value, cause) -> {
            log.debug("AI 服务实例被移除，appId: {}, 原因: {}", key, cause);
        })
        .build();

/**
 * 根据 appId 获取服务（带缓存）
 */
public AiCodeGeneratorService getAiCodeGeneratorService(long appId) {
    return serviceCache.get(appId, this::createAiCodeGeneratorService);
}

/**
 * 创建新的 AI 服务实例
 */
private AiCodeGeneratorService createAiCodeGeneratorService(long appId) {
    log.info("为 appId: {} 创建新的 AI 服务实例", appId);
    // 根据 appId 构建独立的对话记忆
    MessageWindowChatMemory chatMemory = MessageWindowChatMemory
            .builder()
            .id(appId)
            .chatMemoryStore(redisChatMemoryStore)
            .maxMessages(20)
            .build();
    return AiServices.builder(AiCodeGeneratorService.class)
            .chatModel(chatModel)
            .streamingChatModel(streamingChatModel)
            .chatMemory(chatMemory)
            .build();
}
````
最后修改 AiCodeGeneratorFacade，所有方法使用的 AI Service 改为通过工厂根据 appId 获取 AI Service：
````
@Resource
private AiCodeGeneratorServiceFactory aiCodeGeneratorServiceFactory;

// 根据 appId 获取对应的 AI 服务实例
AiCodeGeneratorService aiCodeGeneratorService = aiCodeGeneratorServiceFactory.getAiCodeGeneratorService(appId);
````
使用这种方‍‍‍‍‍案，不需要改⁡⁡动⁡ ⁡A⁡I S‏‏er‏vi‏ce‏؜؜ 本身؜的代码؜，﻿﻿更符合开؜﻿闭原则﻿。

### 5、历史对话加载
根据方案，‍‍‍‍对话‍记忆初始化⁡时⁡，⁡需⁡要从数据‏库中‏加⁡载‏对话历‏؜史到؜记忆中。

在 ChatHistoryService 中开发加载方法：
````
@Override
public int loadChatHistoryToMemory(Long appId, MessageWindowChatMemory chatMemory, int maxCount) {
    try {
        // 直接构造查询条件，起始点为 1 而不是 0，用于排除最新的用户消息
        QueryWrapper queryWrapper = QueryWrapper.create()
                .eq(ChatHistory::getAppId, appId)
                .orderBy(ChatHistory::getCreateTime, false)
                .limit(1, maxCount);
        List<ChatHistory> historyList = this.list(queryWrapper);
        if (CollUtil.isEmpty(historyList)) {
            return 0;
        }
        // 反转列表，确保按时间正序（老的在前，新的在后）
        historyList = historyList.reversed();
        // 按时间顺序添加到记忆中
        int loadedCount = 0;
        // 先清理历史缓存，防止重复加载
        chatMemory.clear();
        for (ChatHistory history : historyList) {
            if (ChatHistoryMessageTypeEnum.USER.getValue().equals(history.getMessageType())) {
                chatMemory.add(UserMessage.from(history.getMessage()));
                loadedCount++;
            } else if (ChatHistoryMessageTypeEnum.AI.getValue().equals(history.getMessageType())) {
                chatMemory.add(AiMessage.from(history.getMessage()));
                loadedCount++;
            }
        }
        log.info("成功为 appId: {} 加载了 {} 条历史对话", appId, loadedCount);
        return loadedCount;
    } catch (Exception e) {
        log.error("加载历史对话失败，appId: {}, error: {}", appId, e.getMessage(), e);
        // 加载失败不影响系统运行，只是没有历史上下文
        return 0;
    }
}
````
注意上述代码中的几个重要细节：fCDfNueSlDGO6hY/qZYnExxW5bFfPyC/A+Y7KFDwhD4=

- 查询起始点设置为 1 而不是 0，这是为了排除最新的用户消息。因为在对话流程中，用户消息被添加到数据库后，AI 服务也会自动将用户消息添加到记忆中，如果不排除会导致消息重复。
- 注意反转从数据库中查到的消息列表，确保加载到记忆中的消息是按时间正序的。
- 加载前先清理 Redis 中的历史对话记忆，防止重复加载。

然后就可以‍‍‍‍‍在初始化 AI Se⁡⁡⁡⁡⁡rvice 的对话记‏‏‏‏‏忆时调用了，这相当于؜؜؜؜؜是懒加载，对话时才会﻿﻿﻿﻿﻿加载记忆，节约内存。
````
private AiCodeGeneratorService createAiCodeGeneratorService(long appId) {
    log.info("为 appId: {} 创建新的 AI 服务实例", appId);
    // 根据 appId 构建独立的对话记忆
    MessageWindowChatMemory chatMemory = MessageWindowChatMemory
            .builder()
            .id(appId)
            .chatMemoryStore(redisChatMemoryStore)
            .maxMessages(20)
            .build();
    // 从数据库加载历史对话到记忆中
    chatHistoryService.loadChatHistoryToMemory(appId, chatMemory, 20);
    return AiServices.builder(AiCodeGeneratorService.class)
            .chatModel(chatModel)
            .streamingChatModel(streamingChatModel)
            .chatMemory(chatMemory)
            .build();
}
````
## 核心逻辑拆解（以四轮对话为例）：

### 为了方便说明，先定义四轮对话：

第一轮：用户说 Q1 → AI 回复 A1

第二轮：用户说 Q2 → AI 回复 A2

第三轮：用户说 Q3 → AI 回复 A3

第四轮：用户说 Q4 → AI 回复 A4

### 1. 首次获取 AI 服务实例（触发缓存创建）
   当你发起第一轮对话（Q1）时，getAiCodeGeneratorService(appId) 会检查 Caffeine 缓存：

   缓存中无该 appId 的实例，触发 createAiCodeGeneratorService(appId)

   创建 MessageWindowChatMemory 实例（独立对话记忆，maxMessages=20）

   调用 loadChatHistoryToMemory：此时数据库无该 appId 的历史，加载 0 条记录

   构建并返回 AiCodeGeneratorService 实例，存入缓存（缓存规则：最多 1000 个、写入 30 分钟过期、访问 10 分钟过期）

### 2. 第一轮对话（Q1 → A1）的记忆存储
   执行 chatToGenCode 方法：

   校验通过后，调用 chatHistoryService.addChatMessage：将 Q1（USER 类型）写入数据库

   调用 AI 生成流式响应 A1，通过 doOnComplete 收集完整响应后：

   调用 chatHistoryService.addChatMessage：将 A1（AI 类型）写入数据库

   此时，MessageWindowChatMemory 内存中会记录 [Q1, A1]（AI 框架自动维护），数据库也持久化了这两条记录

### 3. 第二轮对话（Q2 → A2）的记忆存储
   再次调用 getAiCodeGeneratorService(appId)：缓存未过期，直接返回已有的服务实例

   执行 chatToGenCode：

   写入 Q2 到数据库

   AI 生成 A2 时，会读取内存中已有的 [Q1, A1] 作为上下文

   完成后写入 A2 到数据库

   内存记忆更新为 [Q1, A1, Q2, A2]，数据库新增 Q2、A2 两条记录

### 4. 第三、四轮对话（Q3→A3、Q4→A4）的记忆存储
   流程和第二轮完全一致：

   缓存未过期时，复用同一个 AiCodeGeneratorService 实例，内存记忆持续追加：

   第三轮后：[Q1, A1, Q2, A2, Q3, A3]

   第四轮后：[Q1, A1, Q2, A2, Q3, A3, Q4, A4]

   每轮对话的用户消息和 AI 回复都会实时写入数据库持久化

### 5. 缓存过期 / 移除后的记忆恢复
   如果缓存因「访问后 10 分钟未使用」或「写入后 30 分钟」过期，或缓存数量超 1000 被移除：

   再次发起对话时，会重新调用 createAiCodeGeneratorService(appId)

   此时 loadChatHistoryToMemory 会执行：

   从数据库查询该 appId 的历史记录（Q1/A1/Q2/A2/Q3/A3/Q4/A4）

   排除最新的 1 条（代码中 limit(1, maxCount)，即跳过最新的 A4）

   剩余记录反转后按时间正序加载到 MessageWindowChatMemory 内存中

   内存中恢复大部分历史上下文，保证 AI 能继续基于历史对话回复

