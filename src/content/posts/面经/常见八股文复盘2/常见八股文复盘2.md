---
title: 常见八股文复盘2
published: 2025-12-23
description: ''
image: './cover.png'
tags: ["八股"]
category: '八股'
draft: false 
lang: ''
---

# Java开发实习岗面试问题详细解答
本文针对Java开发实习岗的一面、二面问题进行详细解答，结合实习岗的考察重点，以基础知识点为主，兼顾项目实践和简单应用，采用Markdown格式分点说明。

## 一面问题解答（9分钟）
### 1. 对Java的基础掌握怎么样，集合都有哪些
#### （1）Java基础掌握程度（自述参考）
作为实习岗，主要掌握了Java核心语法（面向对象、异常处理、泛型、注解等）、集合框架、IO流、多线程基础、JDBC等；熟悉Spring Boot、MyBatis等框架的基础使用，能独立完成简单的后端接口开发和数据库交互。

#### （2）Java集合框架分类
Java集合主要分为**Collection**和**Map**两大体系，核心子类如下：
- **Collection接口**：存储单列元素，分为三大子接口
    - `List`：有序、可重复，底层为动态数组/链表，如`ArrayList`（动态数组）、`LinkedList`（双向链表）、`Vector`（线程安全的动态数组）。
    - `Set`：无序、不可重复，基于哈希表/红黑树实现，如`HashSet`（哈希表）、`LinkedHashSet`（有序哈希表）、`TreeSet`（红黑树，有序）。
    - `Queue`：队列，遵循FIFO（先进先出），如`LinkedList`（双端队列）、`PriorityQueue`（优先级队列）。
- **Map接口**：存储键值对（Key-Value），键唯一、值可重复
    - `HashMap`：哈希表实现，无序、线程不安全。
    - `LinkedHashMap`：继承HashMap，保留插入顺序。
    - `TreeMap`：红黑树实现，按键排序。
    - `Hashtable`：线程安全的哈希表，效率较低。

### 2. String常用的方法
String类是Java中处理字符串的核心类，常用方法可分为以下几类：
- **获取相关**：`length()`（获取长度）、`charAt(int index)`（获取指定索引字符）、`substring(int beginIndex)`/`substring(int beginIndex, int endIndex)`（截取子串）。
- **比较相关**：`equals(Object obj)`（内容比较）、`equalsIgnoreCase(String str)`（忽略大小写比较）、`compareTo(String str)`（按Unicode码值比较）。
- **查找相关**：`indexOf(String str)`（查找子串首次出现位置）、`lastIndexOf(String str)`（查找子串最后出现位置）、`contains(CharSequence s)`（判断是否包含子串）。
- **修改相关**：`replace(CharSequence old, CharSequence new)`（替换子串）、`toUpperCase()`/`toLowerCase()`（大小写转换）、`trim()`/`strip()`（去除空白）、`split(String regex)`（分割字符串）。
- **其他**：`isEmpty()`（判断是否为空）、`concat(String str)`（拼接字符串）、`valueOf(Object obj)`（将其他类型转为字符串）。

### 3. 列举List三个常用的方法
List作为有序集合，常用方法众多，核心三个如下：
1. **`add(E e)`**：向列表末尾添加元素，示例：`list.add("Java");`。
2. **`get(int index)`**：根据索引获取元素，示例：`String s = list.get(0);`。
3. **`remove(int index)/remove(Object o)`**：根据索引或元素删除，示例：`list.remove(1);`/`list.remove("Java");`。
   其他常用：`size()`（获取长度）、`set(int index, E e)`（替换指定索引元素）、`clear()`（清空列表）。

### 4. 数据库的结果集去重、排序、分组用什么命令，分组后怎么进行数据过滤
| 操作         | 命令/关键字                | 说明                                                                 |
|--------------|---------------------------|----------------------------------------------------------------------|
| 结果集去重   | `DISTINCT`                | 加在`SELECT`后，去除重复行，如`SELECT DISTINCT name FROM user;`      |
| 排序         | `ORDER BY 列名 [ASC/DESC]` | `ASC`升序（默认），`DESC`降序，如`SELECT * FROM user ORDER BY age DESC;` |
| 分组         | `GROUP BY 列名`           | 按指定列分组，常与聚合函数配合，如`SELECT age, COUNT(*) FROM user GROUP BY age;` |
| 分组后过滤   | `HAVING`                  | 分组后对结果过滤（区别于`WHERE`：`WHERE`过滤行，`HAVING`过滤分组），如`SELECT age, COUNT(*) FROM user GROUP BY age HAVING COUNT(*) > 2;` |

**示例**：查询用户表中不同年龄的用户数，且只显示用户数大于2的年龄分组
```sql
SELECT age, COUNT(*) AS user_count 
FROM user 
WHERE gender = '男'  -- 先过滤行
GROUP BY age         -- 再分组
HAVING user_count > 2; -- 最后过滤分组
```

### 5. Java面向对象的特征有哪些
Java面向对象的核心特征为**封装、继承、多态**，部分教材会包含**抽象**，共四大特征：
1. **封装**：将对象的属性和行为封装起来，隐藏内部实现细节，仅通过公共方法暴露接口，提高代码安全性和可维护性。
2. **继承**：子类继承父类的属性和方法，实现代码复用，子类可扩展或重写父类功能，Java中通过`extends`实现，单继承、多实现。
3. **多态**：同一行为在不同对象上表现出不同形式，分为编译时多态（方法重载）和运行时多态（方法重写+父类引用指向子类对象）。
4. **抽象**：提取事物的共性特征，通过抽象类或接口定义规范，不提供具体实现，强制子类实现细节，降低耦合。

### 6. 将手机作为一个对象，通俗易懂地分享一下对封装、继承、多态三个特征的理解
以**手机**为对象，结合生活场景解释三大特征：
#### （1）封装
手机的内部组件（如芯片、电池、摄像头）是“属性”，打电话、拍照是“方法”。我们使用手机时，不需要知道芯片如何运算、摄像头如何成像（隐藏内部细节），只需点击屏幕上的“电话”“相机”图标（调用公共方法），这就是封装。
在代码中，手机类的属性（`cpu`、`battery`）设为`private`，通过`setCpu()`、`takePhoto()`等`public`方法访问和操作，避免属性被随意修改。

#### （2）继承
手机有不同品牌：华为手机、苹果手机、小米手机，它们都继承了“手机”的基础功能（打电话、发短信、上网），这是父类的共性；同时，每个品牌又有自己的特色功能（如华为的鸿蒙系统、苹果的Face ID），这是子类的扩展。
在代码中，定义`Phone`父类包含`call()`、`sendMessage()`方法，`HuaWeiPhone`、`IPhone`子类继承`Phone`，并新增`harmonyOS()`、`faceID()`方法。

#### （3）多态
同样是“拍照”方法，华为手机的拍照支持50倍变焦，苹果手机的拍照支持人像模式，小米手机的拍照支持夜景模式——同一“拍照”行为，不同手机表现出不同效果，这就是多态。
在代码中，父类`Phone`定义`takePhoto()`方法，子类`HuaWeiPhone`、`IPhone`重写该方法实现不同逻辑，通过`Phone phone = new HuaWeiPhone(); phone.takePhoto();`调用，运行时会执行子类的实现。

### 7. 介绍项目，项目里遇到的难点
#### （1）项目介绍（实习岗参考示例）
- **项目名称**：校园二手交易平台（Spring Boot + MyBatis + Vue）
- **项目职责**：负责后端接口开发，包括用户模块（注册、登录、信息修改）、商品模块（发布、查询、删除）、订单模块（创建、支付状态更新）；设计数据库表（用户表、商品表、订单表）；实现简单的权限控制（普通用户/管理员）。
- **技术栈**：Spring Boot、MyBatis、MySQL、Redis（缓存热门商品）、Vue + Element UI（前端）。

#### （2）项目难点及解决方法（实习岗真实场景参考）
1. **难点1**：商品列表分页查询效率低
    - 问题：商品表数据量增大后，`SELECT * FROM goods LIMIT 10000, 10`这类大偏移量分页查询耗时较长。
    - 解决：通过**主键索引优化**，改为`SELECT * FROM goods WHERE id > 10000 LIMIT 10`；同时用Redis缓存热门商品的分页结果，减少数据库查询。

2. **难点2**：用户登录状态保持与权限控制
    - 问题：如何实现用户登录后跨页面保持状态，且区分普通用户和管理员的操作权限。
    - 解决：使用**Session**存储用户登录信息，结合拦截器（Interceptor）拦截请求，检查Session中是否有用户信息，以及用户角色是否为管理员，若未登录或权限不足则重定向到登录页。

3. **难点3**：商品发布时的图片上传与存储
    - 问题：前端上传的商品图片如何接收并存储，且保证访问速度。
    - 解决：后端通过`MultipartFile`接收图片，将图片保存到服务器本地，同时将图片路径存入数据库；为了提高访问速度，后续将图片迁移到阿里云OSS对象存储，通过OSS的URL访问图片。

## 二面问题解答（27分钟）
### 1. 项目的前端是自己写的吗？
（根据实际情况回答，实习岗常见情况参考）
- 情况1：前端自己独立开发
  “项目的前端是我基于Vue + Element UI独立开发的，包括页面布局、组件封装（如商品卡片、分页组件）、前后端接口联调等。因为是实习项目，功能相对简单，主要实现了用户交互、数据展示和表单提交等功能。”
- 情况2：前端和同学协作开发/使用现成模板
  “项目的前端部分我主要负责了商品列表、用户中心等页面的开发，和同学协作完成了首页和订单页面；部分通用组件（如导航栏、分页）使用了Element UI的现成组件，减少开发工作量。同时，我负责了前后端接口的联调，确保前端能正确接收和展示后端返回的数据。”

### 2. 大学专业是什么，学过python吗，vue和react有了解过吗？
（结合自身专业和学习情况回答，示例参考）
1. **大学专业**：我本科的专业是**计算机科学与技术**（或软件工程、信息管理与信息系统等），专业课程涵盖了编程语言、数据结构、数据库、计算机网络等，为Java开发打下了基础。
2. **Python学习情况**：学过Python，主要掌握了Python的基础语法、爬虫（使用requests + BeautifulSoup爬取网页数据）、数据分析（Pandas库）等，做过简单的校园新闻爬虫项目。虽然Python的使用经验不如Java，但因为有编程语言的共性，上手起来比较快。
3. **Vue和React了解情况**：
    - **Vue**：有实际项目使用经验，掌握了Vue的核心语法（如指令、组件、路由、Vuex），能使用Vue + Element UI开发前端页面，完成前后端交互。
    - **React**：目前主要是理论学习，了解了React的核心概念（如虚拟DOM、组件化、JSX语法），做过简单的React demo（如待办事项列表），因为React的学习曲线稍陡，还需要更多实践来巩固。

### 3. 字符串String为什么是不可变的？
String的不可变性是Java的核心设计，主要由**底层实现**和**访问控制**决定：
1. **底层存储的不可变**：Java 9及以后，String底层使用`private final byte[] value`存储字符（Java 8及以前为`char[]`），`final`修饰使得`value`数组的引用无法被修改，即不能指向新的数组。
2. **访问权限控制**：`value`数组被`private`修饰，String类未提供任何修改`value`数组元素的方法，外部无法直接操作数组内容。
3. **无修改方法**：String的拼接（`+`）、替换（`replace`）等操作，都不会修改原字符串，而是返回一个新的String对象。

**不可变性的优势**：线程安全、支持字符串常量池、缓存哈希码、提高安全性（如文件路径不会被恶意修改）。

### 4. 字符串怎么转成一个整型？
Java中字符串转整型主要通过`Integer`类的静态方法实现，核心有两种：
1. **`Integer.parseInt(String s)`**：返回`int`基本类型，若字符串格式非法（如包含非数字字符），会抛出`NumberFormatException`。
   ```java
   String str = "123";
   int num = Integer.parseInt(str); // 结果：123
   ```
2. **`Integer.valueOf(String s)`**：返回`Integer`包装类，内部调用`parseInt()`，且会缓存`-128~127`之间的整数对象，减少内存开销。
   ```java
   String str = "456";
   Integer numObj = Integer.valueOf(str);
   int num = numObj; // 自动拆箱为int，结果：456
   ```
**异常处理**：转换时需捕获`NumberFormatException`，避免程序崩溃：
```java
try {
    int num = Integer.parseInt("abc");
} catch (NumberFormatException e) {
    System.out.println("字符串格式不是有效整数");
}
```

### 5. 创建ArrayList的时候不赋值，它的初始值是多少，扩容机制是怎样的？
#### （1）初始容量
- **Java 8及以后**：使用无参构造器`new ArrayList()`时，底层数组`elementData`初始化为**空数组**（`DEFAULTCAPACITY_EMPTY_ELEMENTDATA`），首次添加元素时才会扩容至**10**。
- **Java 7及以前**：无参构造器直接将初始容量设为10。

#### （2）扩容机制
ArrayList基于动态数组实现，当数组容量不足时自动扩容，核心流程：
1. **触发条件**：添加元素时，若当前元素数量（`size`）等于数组容量（`elementData.length`），触发扩容。
2. **扩容计算**：新容量 = 旧容量 + 旧容量 / 2（即扩容1.5倍），通过位运算`oldCapacity >> 1`实现。
3. **特殊情况**：
    - 若计算后的新容量仍小于所需最小容量（如批量添加大量元素），则直接扩容至所需最小容量。
    - 首次添加元素时，从0扩容至10。
4. **数组复制**：通过`Arrays.copyOf()`将原数组元素复制到新的扩容数组中，`elementData`指向新数组。

**简化源码示例**：
```java
private void grow(int minCapacity) {
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity >> 1); // 1.5倍扩容
    if (newCapacity - minCapacity < 0)
        newCapacity = minCapacity;
    elementData = Arrays.copyOf(elementData, newCapacity);
}
```

### 6. List和数组之间怎么相互转换
#### （1）数组转List
1. **`Arrays.asList(T... a)`**：
    - 所属类：`java.util.Arrays`。
    - 特点：返回的是`Arrays`的内部类`ArrayList`（非`java.util.ArrayList`），不支持增删操作。
    - 示例：
      ```java
      String[] arr = {"a", "b", "c"};
      List<String> list = Arrays.asList(arr);
      ```
2. **`new ArrayList<>(Collection)`**：
    - 特点：将`Arrays.asList()`的结果转为真正的`ArrayList`，支持增删。
    - 示例：
      ```java
      String[] arr = {"a", "b", "c"};
      List<String> arrayList = new ArrayList<>(Arrays.asList(arr));
      ```

#### （2）List转数组
1. **`List.toArray()`**：返回`Object[]`数组，无泛型，需强制类型转换。
   ```java
   List<String> list = new ArrayList<>();
   list.add("a");
   Object[] arr = list.toArray();
   ```
2. **`List.toArray(T[] a)`**：返回指定类型的数组，推荐使用。
   ```java
   List<String> list = new ArrayList<>();
   list.add("a");
   String[] arr = list.toArray(new String[0]); // 传入空数组，自动匹配长度
   ```

### 7. List怎么重写排序
List排序主要通过**实现`Comparable`接口**（自然排序）或**传入`Comparator`比较器**（定制排序）实现，后者更灵活（无需修改实体类）。

#### （1）实现`Comparable`接口（实体类内部定义规则）
```java
// 实体类实现Comparable接口，重写compareTo方法
class Student implements Comparable<Student> {
    private String name;
    private int age;

    @Override
    public int compareTo(Student o) {
        return this.age - o.age; // 按年龄升序，降序则为o.age - this.age
    }

    // 构造器、getter/setter
}

// 排序调用
List<Student> list = new ArrayList<>();
list.add(new Student("张三", 20));
list.add(new Student("李四", 18));
Collections.sort(list); // 或list.sort(null);
```

#### （2）传入`Comparator`比较器（外部定义规则）
```java
List<Student> list = new ArrayList<>();
list.add(new Student("张三", 20));
list.add(new Student("李四", 18));

// 按姓名长度排序（Lambda表达式）
list.sort(Comparator.comparingInt(s -> s.getName().length()));

// 按年龄降序（匿名内部类）
list.sort(new Comparator<Student>() {
    @Override
    public int compare(Student s1, Student s2) {
        return s2.getAge() - s1.getAge();
    }
});
```

### 8. 有一个List里面放了100个字符串String，怎么做才能删除掉包含a的字符串
需避免循环中删除元素的**并发修改异常**和**索引越界**问题，推荐三种安全方式：

#### （1）使用迭代器的`remove()`方法
```java
List<String> list = new ArrayList<>(Arrays.asList("a", "ab", "c", "ad"));
Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
    String s = iterator.next();
    if (s.contains("a")) {
        iterator.remove(); // 安全删除
    }
}
```

#### （2）使用Java 8+的`removeIf()`方法（最简洁）
```java
List<String> list = new ArrayList<>(Arrays.asList("a", "ab", "c", "ad"));
list.removeIf(s -> s.contains("a")); // 按条件删除
```

#### （3）倒序索引遍历
```java
List<String> list = new ArrayList<>(Arrays.asList("a", "ab", "c", "ad"));
for (int i = list.size() - 1; i >= 0; i--) {
    if (list.get(i).contains("a")) {
        list.remove(i); // 倒序删除，无索引问题
    }
}
```

### 9. HashMap是有序的还是无序的，哪个Map是有序的
#### （1）HashMap的有序性
`HashMap`是**无序**的，因为它基于哈希表实现，元素的存储位置由`hashCode()`和哈希算法决定，插入顺序与遍历顺序不一致，且扩容后顺序可能变化。

#### （2）有序的Map类
1. **`LinkedHashMap`**：继承HashMap，通过**双向链表**保留**插入顺序**或**访问顺序**（按`get/put`频率排序），性能与HashMap接近。
   ```java
   Map<String, Integer> map = new LinkedHashMap<>();
   map.put("c", 3);
   map.put("a", 1);
   map.put("b", 2);
   System.out.println(map); // 输出：{c=3, a=1, b=2}（保留插入顺序）
   ```
2. **`TreeMap`**：基于**红黑树**实现，按**键的自然顺序**（实现`Comparable`）或**自定义比较器**排序，适用于需要按键排序的场景。
   ```java
   Map<String, Integer> map = new TreeMap<>();
   map.put("c", 3);
   map.put("a", 1);
   map.put("b", 2);
   System.out.println(map); // 输出：{a=1, b=2, c=3}（按键升序）
   ```

### 10. 怎么循环迭代打印HashMap的key和value
HashMap的遍历方式主要有以下几种：

#### （1）`entrySet()`遍历（推荐，效率高）
```java
Map<String, Integer> map = new HashMap<>();
map.put("a", 1);
map.put("b", 2);

for (Map.Entry<String, Integer> entry : map.entrySet()) {
    System.out.println("key: " + entry.getKey() + ", value: " + entry.getValue());
}
```

#### （2）`keySet()` + `get()`遍历（效率低，二次哈希）
```java
for (String key : map.keySet()) {
    Integer value = map.get(key);
    System.out.println("key: " + key + ", value: " + value);
}
```

#### （3）Java 8+ `forEach()`遍历（简洁）
```java
map.forEach((key, value) -> System.out.println("key: " + key + ", value: " + value));
```

#### （4）迭代器遍历（支持删除元素）
```java
Iterator<Map.Entry<String, Integer>> iterator = map.entrySet().iterator();
while (iterator.hasNext()) {
    Map.Entry<String, Integer> entry = iterator.next();
    System.out.println("key: " + entry.getKey() + ", value: " + entry.getValue());
}
```

### 11. 怎么做才能在不丢失精度的情况下累加小数
Java中`float`和`double`是浮点数，存在精度丢失问题（如`0.1 + 0.2 ≠ 0.3`），需使用**`java.math.BigDecimal`**类进行高精度运算。

#### （1）正确累加方式
```java
import java.math.BigDecimal;

public class BigDecimalDemo {
    public static void main(String[] args) {
        BigDecimal sum = BigDecimal.ZERO;
        // 累加的小数需通过BigDecimal的字符串构造器创建（避免浮点数传入）
        sum = sum.add(new BigDecimal("0.1"));
        sum = sum.add(new BigDecimal("0.2"));
        sum = sum.add(new BigDecimal("0.3"));
        System.out.println(sum); // 输出：0.6，无精度丢失
    }
}
```

#### （2）注意事项
- 避免使用`BigDecimal(double val)`构造器（仍会有精度问题），优先使用`BigDecimal(String val)`。
- 累加时调用`add()`方法，减法用`subtract()`，乘法用`multiply()`，除法用`divide()`（需指定精度和舍入模式）。

### 12. 怎么写一个线程
Java中创建线程主要有**继承Thread类**、**实现Runnable接口**、**实现Callable接口（带返回值）**三种方式：

#### （1）继承Thread类
```java
class MyThread extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println(Thread.currentThread().getName() + ": " + i);
        }
    }
}

// 启动线程
public class ThreadDemo {
    public static void main(String[] args) {
        MyThread thread = new MyThread();
        thread.start(); // 启动线程，执行run()方法
    }
}
```

#### （2）实现Runnable接口（推荐，避免单继承限制）
```java
class MyRunnable implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println(Thread.currentThread().getName() + ": " + i);
        }
    }
}

// 启动线程
public class ThreadDemo {
    public static void main(String[] args) {
        MyRunnable runnable = new MyRunnable();
        Thread thread = new Thread(runnable);
        thread.start();
    }
}
```

#### （3）实现Callable接口（带返回值）
```java
import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;

class MyCallable implements Callable<Integer> {
    @Override
    public Integer call() throws Exception {
        int sum = 0;
        for (int i = 1; i <= 100; i++) {
            sum += i;
        }
        return sum;
    }
}

// 启动线程
public class ThreadDemo {
    public static void main(String[] args) throws Exception {
        MyCallable callable = new MyCallable();
        FutureTask<Integer> futureTask = new FutureTask<>(callable);
        Thread thread = new Thread(futureTask);
        thread.start();
        Integer result = futureTask.get(); // 获取返回值
        System.out.println("1到100的和：" + result);
    }
}
```

### 13. 字节流和字符流之间怎么相互转换
Java通过**转换流**实现字节流和字符流的相互转换，核心类为`InputStreamReader`（字节流转字符流）和`OutputStreamWriter`（字符流转字节流），二者均继承自`Reader/Writer`，是字节流和字符流的桥梁。

#### （1）字节流转字符流（InputStreamReader）
```java
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.io.Reader;

public class StreamConvert {
    public static void main(String[] args) throws Exception {
        // 字节输入流（FileInputStream）转字符输入流（InputStreamReader）
        FileInputStream fis = new FileInputStream("test.txt");
        Reader reader = new InputStreamReader(fis, "UTF-8"); // 指定编码
        int ch;
        while ((ch = reader.read()) != -1) {
            System.out.print((char) ch);
        }
        reader.close();
        fis.close();
    }
}
```

#### （2）字符流转字节流（OutputStreamWriter）
```java
import java.io.FileOutputStream;
import java.io.OutputStreamWriter;
import java.io.Writer;

public class StreamConvert {
    public static void main(String[] args) throws Exception {
        // 字符输出流（OutputStreamWriter）转字节输出流（FileOutputStream）
        FileOutputStream fos = new FileOutputStream("test.txt");
        Writer writer = new OutputStreamWriter(fos, "UTF-8");
        writer.write("Hello Java");
        writer.close();
        fos.close();
    }
}
```

### 14. get请求和post请求有什么区别
GET和POST是HTTP协议中最常用的请求方法，核心区别如下：

| 特性         | GET请求                          | POST请求                          |
|--------------|----------------------------------|----------------------------------|
| **请求参数** | 参数拼接在URL后，可见（如`?name=java&age=20`） | 参数放在请求体中，不可见          |
| **数据长度** | 受URL长度限制（一般2KB）         | 无长度限制，可传输大量数据        |
| **安全性**   | 低，参数暴露在URL中，易被截取    | 高，参数在请求体中，可加密传输    |
| **缓存**     | 可被浏览器缓存                   | 一般不被缓存                     |
| **幂等性**   | 幂等（多次请求结果相同）         | 非幂等（多次请求可能产生不同结果，如提交订单） |
| **适用场景** | 数据查询（如分页、搜索）         | 数据提交/修改（如登录、注册、上传文件） |

### 15. 怎么写一个过滤器（项目的拦截器）
#### （1）过滤器（Filter）的编写（Servlet规范）
过滤器用于拦截HTTP请求，实现编码处理、登录验证等，步骤如下：
1. **实现`Filter`接口**：
   ```java
   import javax.servlet.*;
   import javax.servlet.annotation.WebFilter;
   import javax.servlet.http.HttpServletRequest;
   import javax.servlet.http.HttpServletResponse;
   import java.io.IOException;

   @WebFilter("/*") // 过滤所有请求
   public class LoginFilter implements Filter {
       @Override
       public void init(FilterConfig filterConfig) throws ServletException {
           // 初始化方法，仅执行一次
       }

       @Override
       public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
           HttpServletRequest req = (HttpServletRequest) request;
           HttpServletResponse resp = (HttpServletResponse) response;

           // 排除登录页
           String path = req.getRequestURI();
           if (path.contains("/login")) {
               chain.doFilter(request, response); // 放行
               return;
           }

           // 检查登录状态
           if (req.getSession().getAttribute("user") == null) {
               resp.sendRedirect(req.getContextPath() + "/login"); // 重定向到登录页
               return;
           }

           chain.doFilter(request, response); // 放行
       }

       @Override
       public void destroy() {
           // 销毁方法，服务器关闭时执行
       }
   }
   ```
2. **配置过滤器**：使用`@WebFilter`注解（Servlet 3.0+），或在`web.xml`中配置：
   ```xml
   <filter>
       <filter-name>LoginFilter</filter-name>
       <filter-class>com.filter.LoginFilter</filter-class>
   </filter>
   <filter-mapping>
       <filter-name>LoginFilter</filter-name>
       <url-pattern>/*</url-pattern>
   </filter-mapping>
   ```

#### （2）SpringMVC拦截器（Interceptor）的编写（项目常用）
拦截器是SpringMVC的组件，更灵活，步骤如下：
1. **实现`HandlerInterceptor`接口**：
   ```java
   import org.springframework.web.servlet.HandlerInterceptor;
   import org.springframework.web.servlet.ModelAndView;
   import javax.servlet.http.HttpServletRequest;
   import javax.servlet.http.HttpServletResponse;

   public class LoginInterceptor implements HandlerInterceptor {
       @Override
       public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
           // 预处理，返回true放行，false拦截
           if (request.getSession().getAttribute("user") == null) {
               response.sendRedirect(request.getContextPath() + "/login");
               return false;
           }
           return true;
       }

       @Override
       public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
           // 处理请求后调用
       }

       @Override
       public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
           // 视图渲染后调用
       }
   }
   ```
2. **注册拦截器**：
   ```java
   import org.springframework.context.annotation.Configuration;
   import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
   import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

   @Configuration
   public class WebConfig implements WebMvcConfigurer {
       @Override
       public void addInterceptors(InterceptorRegistry registry) {
           registry.addInterceptor(new LoginInterceptor())
                   .addPathPatterns("/**") // 拦截所有请求
                   .excludePathPatterns("/login", "/static/**"); // 排除登录页和静态资源
       }
   }
   ```

### 16. 有一个第三方的系统的post接口，要怎么在项目中去调用这个post接口
Java中调用第三方POST接口主要使用**`HttpClient`（Apache）**、**`RestTemplate`（Spring）**、**`OkHttp`**等工具，以下是最常用的两种方式：

#### （1）使用Apache HttpClient
1. **引入依赖**（Maven）：
   ```xml
   <dependency>
       <groupId>org.apache.httpcomponents</groupId>
       <artifactId>httpclient</artifactId>
       <version>4.5.14</version>
   </dependency>
   ```
2. **调用POST接口**：
   ```java
   import org.apache.http.client.methods.HttpPost;
   import org.apache.http.entity.StringEntity;
   import org.apache.http.impl.client.CloseableHttpClient;
   import org.apache.http.impl.client.HttpClients;
   import org.apache.http.util.EntityUtils;

   public class HttpClientPost {
       public static void main(String[] args) throws Exception {
           CloseableHttpClient client = HttpClients.createDefault();
           HttpPost post = new HttpPost("https://api.example.com/login"); // 第三方接口地址

           // 设置请求头和参数（JSON格式）
           post.setHeader("Content-Type", "application/json");
           String jsonParam = "{\"username\":\"admin\",\"password\":\"123456\"}";
           StringEntity entity = new StringEntity(jsonParam, "UTF-8");
           post.setEntity(entity);

           // 发送请求并获取响应
           String response = EntityUtils.toString(client.execute(post).getEntity(), "UTF-8");
           System.out.println("响应结果：" + response);
           client.close();
       }
   }
   ```

#### （2）使用Spring RestTemplate（Spring项目推荐）
1. **配置RestTemplate**：
   ```java
   import org.springframework.context.annotation.Bean;
   import org.springframework.context.annotation.Configuration;
   import org.springframework.web.client.RestTemplate;

   @Configuration
   public class RestTemplateConfig {
       @Bean
       public RestTemplate restTemplate() {
           return new RestTemplate();
       }
   }
   ```
2. **调用POST接口**：
   ```java
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.stereotype.Service;
   import org.springframework.web.client.RestTemplate;

   @Service
   public class ThirdPartyService {
       @Autowired
       private RestTemplate restTemplate;

       public String callPostApi() {
           String url = "https://api.example.com/login";
           // 请求参数
           User user = new User("admin", "123456");
           // 调用POST接口
           return restTemplate.postForObject(url, user, String.class);
       }

       static class User {
           private String username;
           private String password;
           // 构造器、getter/setter
       }
   }
   ```

### 17. 在mybatis的xml中，怎么返回一个bean对象
MyBatis中返回Bean对象（实体类）主要通过**`resultType`**或**`resultMap`**配置，核心是保证数据库字段与Bean属性的映射关系。

#### （1）使用`resultType`（简单映射，字段名与属性名一致）
```xml
<!-- User实体类：属性id、name、age，对应数据库user表的id、name、age字段 -->
<select id="getUserById" resultType="com.entity.User">
    SELECT id, name, age FROM user WHERE id = #{id}
</select>
```
- 注意：`resultType`直接指定实体类的全限定名或别名（需配置别名包）。

#### （2）使用`resultMap`（复杂映射，字段名与属性名不一致/关联查询）
```xml
<!-- 数据库字段user_id、user_name，对应Bean属性userId、userName -->
<resultMap id="UserResultMap" type="com.entity.User">
    <id column="user_id" property="userId"/> <!-- 主键映射 -->
    <result column="user_name" property="userName"/> <!-- 普通字段映射 -->
    <result column="age" property="age"/>
</resultMap>

<select id="getUserById" resultMap="UserResultMap">
    SELECT user_id, user_name, age FROM user WHERE user_id = #{id}
</select>
```

### 18. 怎么在项目里面使用两种数据库，怎么配置数据库
Spring Boot项目中配置多数据源（如MySQL + Oracle），需**配置多个数据源**、**指定Mapper扫描路径**、**配置SqlSessionFactory**，步骤如下：

#### （1）引入依赖（pom.xml）
```xml
<!-- MySQL驱动 -->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <scope>runtime</scope>
</dependency>
<!-- Oracle驱动 -->
<dependency>
    <groupId>com.oracle.database.jdbc</groupId>
    <artifactId>ojdbc8</artifactId>
    <version>21.3.0.0</version>
</dependency>
<!-- MyBatis + 连接池 -->
<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
    <version>2.3.0</version>
</dependency>
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid-spring-boot-starter</artifactId>
    <version>1.2.16</version>
</dependency>
```

#### （2）配置多数据源（application.yml）
```yaml
spring:
  datasource:
    # MySQL数据源
    mysql:
      driver-class-name: com.mysql.cj.jdbc.Driver
      url: jdbc:mysql://localhost:3306/test_mysql?serverTimezone=Asia/Shanghai
      username: root
      password: root
    # Oracle数据源
    oracle:
      driver-class-name: oracle.jdbc.driver.OracleDriver
      url: jdbc:oracle:thin:@localhost:1521:ORCL
      username: scott
      password: tiger
```

#### （3）配置数据源和SqlSessionFactory
- **MySQL数据源配置**：
  ```java
  import org.mybatis.spring.annotation.MapperScan;
  import org.springframework.boot.context.properties.ConfigurationProperties;
  import org.springframework.boot.jdbc.DataSourceBuilder;
  import org.springframework.context.annotation.Bean;
  import org.springframework.context.annotation.Configuration;
  import org.springframework.context.annotation.Primary;
  import org.apache.ibatis.session.SqlSessionFactory;
  import org.mybatis.spring.SqlSessionFactoryBean;
  import javax.sql.DataSource;

  @Configuration
  @MapperScan(basePackages = "com.mapper.mysql", sqlSessionFactoryRef = "mysqlSqlSessionFactory")
  public class MysqlDataSourceConfig {
      @Bean(name = "mysqlDataSource")
      @Primary
      @ConfigurationProperties(prefix = "spring.datasource.mysql")
      public DataSource mysqlDataSource() {
          return DataSourceBuilder.create().build();
      }

      @Bean(name = "mysqlSqlSessionFactory")
      @Primary
      public SqlSessionFactory mysqlSqlSessionFactory(DataSource dataSource) throws Exception {
          SqlSessionFactoryBean bean = new SqlSessionFactoryBean();
          bean.setDataSource(dataSource);
          bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources("classpath:mapper/mysql/*.xml"));
          return bean.getObject();
      }
  }
  ```
- **Oracle数据源配置**：
  ```java
  @Configuration
  @MapperScan(basePackages = "com.mapper.oracle", sqlSessionFactoryRef = "oracleSqlSessionFactory")
  public class OracleDataSourceConfig {
      @Bean(name = "oracleDataSource")
      @ConfigurationProperties(prefix = "spring.datasource.oracle")
      public DataSource oracleDataSource() {
          return DataSourceBuilder.create().build();
      }

      @Bean(name = "oracleSqlSessionFactory")
      public SqlSessionFactory oracleSqlSessionFactory(@Qualifier("oracleDataSource") DataSource dataSource) throws Exception {
          SqlSessionFactoryBean bean = new SqlSessionFactoryBean();
          bean.setDataSource(dataSource);
          bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources("classpath:mapper/oracle/*.xml"));
          return bean.getObject();
      }
  }
  ```

#### （4）使用多数据源
将不同数据库的Mapper分别放在`com.mapper.mysql`和`com.mapper.oracle`包下，Service中注入对应Mapper即可操作不同数据库。

### 19. MySQL的分页要怎么写，limit后面的两个参数是什么（每页10条数据，如果要查第三页的数据，limit后面两个数字分别是什么）
#### （1）MySQL分页语法
MySQL通过`LIMIT`关键字实现分页，语法：
```sql
SELECT 列名 FROM 表名 [WHERE 条件] [ORDER BY 列名] LIMIT 偏移量, 条数;
```
- **偏移量**：从第几条记录开始（从0计数）。
- **条数**：查询的记录数。

#### （2）参数计算
每页10条数据，查询第三页：
- 偏移量 = (页码 - 1) × 每页条数 = (3 - 1) × 10 = 20。
- 条数 = 10。
- SQL语句：`SELECT * FROM user LIMIT 20, 10;`。

### 20. 有两个表：a表和b表，它们的数据结构完全相同，都有3个字段。每个表中各有5行数据。现在需要将这两个表的数据合并到一起，查询出一个结果集，结果集中包含3列，总共有10行数据，要怎么做
使用MySQL的**`UNION ALL`**关键字实现**行合并**，`UNION ALL`会保留两个表的所有行（包括重复行），最终得到10行数据。

#### （1）SQL语句
```sql
-- 合并a表和b表的所有数据，共10行
SELECT col1, col2, col3 FROM a
UNION ALL
SELECT col1, col2, col3 FROM b;
```

#### （2）注意事项
- 若使用`UNION`而非`UNION ALL`，会自动去除两个表中的重复行，结果行数可能小于10。
- 两个表的字段数、字段类型必须一致，否则会报错。