---
title: 常见八股复盘1
published: 2025-12-23
description: ''
image: './cover'
tags: ["面经"]
category: '面经'
draft: false 
lang: ''
---
# Java与数据库等高频问题详细解答
本文将针对31个Java、数据库、框架等相关问题进行详细解答，采用Markdown语法组织内容，涵盖基础语法、集合、多线程、框架、数据库等多个领域。

## 1. 为何字符串 String 是不可变的？
String的不可变性由其底层实现和Java的设计机制共同决定，核心原因如下：
1. **底层存储的不可变**
    - 在Java 9及以后，String底层使用`private final byte[] value`存储字符，`final`修饰使得`value`数组的引用无法被修改，且`value`为私有属性，外部无法直接访问。
    - Java 8及以前使用`char[]`，同样被`final`和`private`修饰。
2. **无修改方法**：String类未提供任何修改`value`数组元素的方法，所有看似修改的操作（如拼接、替换）都会返回新的String对象。
3. **设计上的优势**
    - **线程安全**：不可变对象在多线程中无需同步，可安全共享。
    - **支持字符串常量池**：常量池可缓存String对象，节省内存。
    - **哈希码缓存**：`hashCode()`基于字符序列计算，不可变性使得哈希码可缓存，提升`HashMap`等集合的性能。
    - **安全性**：作为参数传递（如文件路径、数据库连接串）时，避免被意外修改导致安全问题。

## 2. 如何将字符串转成整数？
Java中主要通过`Integer`类的静态方法实现字符串转整数，核心方法有：
1. **`Integer.parseInt(String s)`**
    - 功能：将字符串转换为`int`类型，要求字符串必须是有效的整数格式，否则抛出`NumberFormatException`。
    - 示例：
      ```java
      String str = "123";
      int num = Integer.parseInt(str); // 结果为123
      ```
2. **`Integer.valueOf(String s)`**
    - 功能：返回`Integer`对象（自动拆箱后可转为`int`），内部调用`parseInt()`，且会缓存-128到127之间的整数对象。
    - 示例：
      ```java
      String str = "456";
      Integer numObj = Integer.valueOf(str);
      int num = numObj; // 结果为456
      ```
3. **处理异常**：转换时需捕获`NumberFormatException`，防止字符串格式非法。
   ```java
   String str = "abc";
   try {
       int num = Integer.parseInt(str);
   } catch (NumberFormatException e) {
       System.out.println("字符串格式不是有效整数");
   }
   ```

## 3. 字符串 String 的最大长度是多少？
String的长度受限于**JVM内存**和**整数类型的取值范围**，具体分为两个层面：
1. **编译期**：字符串字面量的最大长度由`CONSTANT_Utf8_info`结构限制，其长度用2个字节存储，因此最大长度为`2^16 - 1 = 65535`个字符（实际编译时，超过65535会报“常量字符串过长”错误）。
2. **运行期**：String的`length()`方法返回`int`类型，`int`的最大值为`2^31 - 1 = 2147483647`，因此运行时String的最大字符数理论上为2147483647。但实际受限于JVM的堆内存，若字符串过长，会抛出`OutOfMemoryError`。

## 4. new 一个未指定初始容量的 ArrayList 时，初始化容量是多少？
在Java 8及以后版本中，**使用无参构造器`new ArrayList()`时，初始容量为0**，首次添加元素时会扩容至默认的10。具体细节：
1. **底层数组初始化**：无参构造器中，ArrayList的底层数组`elementData`被赋值为一个空数组`DEFAULTCAPACITY_EMPTY_ELEMENTDATA`。
2. **首次扩容**：当调用`add()`添加第一个元素时，会触发扩容，将数组容量设置为默认的10。
3. **Java 7及以前**：无参构造器直接将初始容量设为10。

## 5. ArrayList 的扩容机制是怎样的？
ArrayList基于动态数组实现，当数组容量不足时会自动扩容，核心流程如下：
1. **触发条件**：当添加元素时，发现当前元素数量（`size`）等于数组容量（`elementData.length`），触发扩容。
2. **扩容计算**
    - Java 8及以后：新容量 = 旧容量 + 旧容量 / 2（即扩容1.5倍）。
    - 计算后若新容量仍不足（如批量添加大量元素），则直接扩容至所需容量。
3. **数组复制**：通过`Arrays.copyOf()`将原数组元素复制到新的扩容数组中，`elementData`指向新数组。
4. **特殊情况**：首次添加元素时，从0扩容至10；若指定初始容量为0，后续扩容仍按1.5倍规则。

示例代码（简化的扩容逻辑）：
```java
private void grow(int minCapacity) {
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity >> 1); // 1.5倍扩容
    if (newCapacity - minCapacity < 0)
        newCapacity = minCapacity;
    elementData = Arrays.copyOf(elementData, newCapacity);
}
```

## 6. ArrayList 和数组相互转换的方法是什么？对应的类、方法和包名是什么？
### 6.1 数组转 ArrayList
1. **`Arrays.asList(T... a)`**
    - 所属类：`java.util.Arrays`。
    - 功能：将数组转换为`List`（实际是`Arrays`的内部类`ArrayList`，并非`java.util.ArrayList`，不支持增删操作）。
    - 示例：
      ```java
      import java.util.Arrays;
      import java.util.List;

      String[] arr = {"a", "b", "c"};
      List<String> list = Arrays.asList(arr);
      ```
2. **`new ArrayList<>(Collection<? extends E> c)`**
    - 所属类：`java.util.ArrayList`。
    - 功能：将`Arrays.asList()`的结果转为真正的`ArrayList`，支持增删。
    - 示例：
      ```java
      import java.util.ArrayList;
      import java.util.Arrays;
      import java.util.List;

      String[] arr = {"a", "b", "c"};
      List<String> arrayList = new ArrayList<>(Arrays.asList(arr));
      ```

### 6.2 ArrayList 转数组
1. **`List.toArray()`**
    - 功能：返回`Object[]`数组，无泛型，需强制类型转换。
    - 示例：
      ```java
      List<String> list = new ArrayList<>();
      list.add("a");
      Object[] arr = list.toArray();
      ```
2. **`List.toArray(T[] a)`**
    - 功能：返回指定类型的数组，推荐使用。
    - 示例：
      ```java
      List<String> list = new ArrayList<>();
      list.add("a");
      String[] arr = list.toArray(new String[0]); // 传入空数组，自动匹配长度
      ```

## 7. 如何重写 List 的排序方法？
List的排序主要依赖`Collections.sort()`或`List.sort()`方法，可通过**实现`Comparable`接口**或**传入`Comparator`比较器**自定义排序规则，后者更灵活（无需修改实体类）。

### 7.1 实现`Comparable`接口（自然排序）
实体类实现`Comparable`接口，重写`compareTo()`方法定义排序规则。
示例：按学生年龄排序
```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

class Student implements Comparable<Student> {
    private String name;
    private int age;

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // 重写compareTo，按年龄升序
    @Override
    public int compareTo(Student o) {
        return this.age - o.age; // 降序则为o.age - this.age
    }

    @Override
    public String toString() {
        return "Student{name='" + name + "', age=" + age + "}";
    }
}

public class SortDemo {
    public static void main(String[] args) {
        List<Student> list = new ArrayList<>();
        list.add(new Student("张三", 20));
        list.add(new Student("李四", 18));
        Collections.sort(list); // 排序
        System.out.println(list); // 输出：[Student{name='李四', age=18}, Student{name='张三', age=20}]
    }
}
```

### 7.2 传入`Comparator`比较器（定制排序）
使用`List.sort(Comparator)`或`Collections.sort(List, Comparator)`，无需修改实体类。
示例：按学生姓名长度排序
```java
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

class Student {
    private String name;
    private int age;

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return "Student{name='" + name + "', age=" + age + "}";
    }
}

public class SortDemo {
    public static void main(String[] args) {
        List<Student> list = new ArrayList<>();
        list.add(new Student("张三", 20));
        list.add(new Student("王五", 22));
        list.add(new Student("赵六儿", 19));

        // 按姓名长度升序排序
        list.sort(Comparator.comparingInt(s -> s.getName().length()));
        System.out.println(list); 
        // 输出：[Student{name='张三', age=20}, Student{name='王五', age=22}, Student{name='赵六儿', age=19}]
    }
}
```

## 8. 在 for 循环里删除列表元素会有什么隐患？
在for循环中删除列表元素主要存在**`ConcurrentModificationException`（并发修改异常）**和**数组越界**隐患，原因如下：
1. **普通for循环（索引遍历）**：若删除元素后未调整索引，会导致后续元素漏遍历，或索引越界。
   ```java
   List<String> list = new ArrayList<>(Arrays.asList("a", "b", "c"));
   for (int i = 0; i < list.size(); i++) {
       if (list.get(i).equals("b")) {
           list.remove(i); // 删除后，后续元素前移，i++会跳过下一个元素
       }
   }
   System.out.println(list); // 结果为[a, c]（无问题），但若删除最后一个元素，可能索引越界
   ```
2. **增强for循环（foreach）**：底层使用迭代器，遍历过程中若直接调用`list.remove()`，会触发`ConcurrentModificationException`，因为迭代器会检测到集合被修改（`modCount`与`expectedModCount`不一致）。
   ```java
   List<String> list = new ArrayList<>(Arrays.asList("a", "b", "c"));
   for (String s : list) {
       if (s.equals("b")) {
           list.remove(s); // 抛出ConcurrentModificationException
       }
   }
   ```

## 9. 如何解决 for 循环删除列表元素导致的数组越界问题（需求：循环中判断字符串等于 a 就删除）？
针对“删除列表中等于`a`的元素”的需求，有以下3种安全解决方案：

### 9.1 使用迭代器的`remove()`方法
迭代器的`remove()`方法会同步`modCount`和`expectedModCount`，避免并发修改异常。
```java
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class RemoveDemo {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>(List.of("a", "b", "a", "c"));
        Iterator<String> iterator = list.iterator();
        while (iterator.hasNext()) {
            String s = iterator.next();
            if ("a".equals(s)) {
                iterator.remove(); // 安全删除
            }
        }
        System.out.println(list); // 输出：[b, c]
    }
}
```

### 9.2 倒序索引遍历
从后往前遍历，删除元素后不会影响前面元素的索引，避免漏遍历和越界。
```java
import java.util.ArrayList;
import java.util.List;

public class RemoveDemo {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>(List.of("a", "b", "a", "c"));
        for (int i = list.size() - 1; i >= 0; i--) {
            if ("a".equals(list.get(i))) {
                list.remove(i); // 倒序删除，无索引问题
            }
        }
        System.out.println(list); // 输出：[b, c]
    }
}
```

### 9.3 Java 8+的`removeIf()`方法
`List`的`removeIf()`方法底层使用迭代器实现，简洁且安全。
```java
import java.util.ArrayList;
import java.util.List;

public class RemoveDemo {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>(List.of("a", "b", "a", "c"));
        list.removeIf(s -> "a".equals(s)); // 直接按条件删除
        System.out.println(list); // 输出：[b, c]
    }
}
```

## 10. HashMap 是否有序？
**HashMap是无序的**，具体体现在：
1. **插入顺序与遍历顺序不一致**：HashMap基于哈希表实现，元素的存储位置由`hashCode()`和哈希算法决定，插入顺序不会被保留。
2. **扩容后顺序可能变化**：当HashMap扩容时，元素会重新哈希并迁移到新的桶中，遍历顺序可能发生改变。

注意：`HashMap`的无序性区别于`LinkedHashMap`（保留插入顺序）和`TreeMap`（按键排序）。

## 11. 若需要有序的 Map，应该使用哪个类？
若需要有序的Map，可根据需求选择以下类：
1. **`LinkedHashMap`**
    - 特性：继承自`HashMap`，通过双向链表保留**插入顺序**或**访问顺序**（按`get/put`访问频率排序）。
    - 适用场景：需要保留插入顺序的场景，性能与`HashMap`接近。
    - 示例：
      ```java
      import java.util.LinkedHashMap;
      import java.util.Map;

      public class LinkedHashMapDemo {
          public static void main(String[] args) {
              Map<String, Integer> map = new LinkedHashMap<>();
              map.put("c", 3);
              map.put("a", 1);
              map.put("b", 2);
              System.out.println(map); // 输出：{c=3, a=1, b=2}（保留插入顺序）
          }
      }
      ```
2. **`TreeMap`**
    - 特性：基于红黑树实现，按**键的自然顺序**（实现`Comparable`）或**自定义比较器**排序。
    - 适用场景：需要对键进行排序的场景，查询、插入、删除时间复杂度为O(log n)。
    - 示例：
      ```java
      import java.util.Map;
      import java.util.TreeMap;

      public class TreeMapDemo {
          public static void main(String[] args) {
              Map<String, Integer> map = new TreeMap<>();
              map.put("c", 3);
              map.put("a", 1);
              map.put("b", 2);
              System.out.println(map); // 输出：{a=1, b=2, c=3}（按键自然排序）
          }
      }
      ```
3. **`ConcurrentSkipListMap`**
    - 特性：线程安全的有序Map，基于跳表实现，按键排序，支持高并发。
    - 适用场景：多线程环境下需要有序的Map。

## 12. HashMap 中除了 entrySet 遍历，还有哪些循环迭代打印所有 key-value 的方法？
HashMap的遍历方式除了`entrySet()`，还有`keySet()`+`get()`、`forEach()`（Java 8+）、`Iterator`迭代器等，具体如下：

### 12.1 `keySet()` + `get()`遍历
先获取所有键，再通过键获取值，效率较低（需二次哈希）。
```java
import java.util.HashMap;
import java.util.Map;

public class HashMapTraverse {
    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();
        map.put("a", 1);
        map.put("b", 2);
        map.put("c", 3);

        for (String key : map.keySet()) {
            Integer value = map.get(key);
            System.out.println("key: " + key + ", value: " + value);
        }
    }
}
```

### 12.2 `forEach()`方法（Java 8+）
使用Lambda表达式，简洁高效。
```java
import java.util.HashMap;
import java.util.Map;

public class HashMapTraverse {
    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();
        map.put("a", 1);
        map.put("b", 2);
        map.put("c", 3);

        map.forEach((key, value) -> System.out.println("key: " + key + ", value: " + value));
    }
}
```

### 12.3 迭代器遍历（`Iterator`）
支持遍历中删除元素，避免并发修改异常。
```java
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;

public class HashMapTraverse {
    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();
        map.put("a", 1);
        map.put("b", 2);
        map.put("c", 3);

        // 迭代器遍历entrySet
        Iterator<Entry<String, Integer>> iterator = map.entrySet().iterator();
        while (iterator.hasNext()) {
            Entry<String, Integer> entry = iterator.next();
            System.out.println("key: " + entry.getKey() + ", value: " + entry.getValue());
        }

        // 迭代器遍历keySet
        Iterator<String> keyIterator = map.keySet().iterator();
        while (keyIterator.hasNext()) {
            String key = keyIterator.next();
            System.out.println("key: " + key + ", value: " + map.get(key));
        }
    }
}
```

### 12.4 遍历values（仅值）
若只需遍历值，使用`values()`方法。
```java
import java.util.HashMap;
import java.util.Map;

public class HashMapTraverse {
    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();
        map.put("a", 1);
        map.put("b", 2);
        map.put("c", 3);

        for (Integer value : map.values()) {
            System.out.println("value: " + value);
        }
    }
}
```

## 13. 如何写一个线程？
Java中创建线程主要有3种方式：**继承`Thread`类**、**实现`Runnable`接口**、**实现`Callable`接口（带返回值）**。

### 13.1 继承`Thread`类
重写`run()`方法，调用`start()`启动线程。
```java
class MyThread extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println(Thread.currentThread().getName() + ": " + i);
        }
    }
}

public class ThreadDemo {
    public static void main(String[] args) {
        MyThread thread1 = new MyThread();
        MyThread thread2 = new MyThread();
        thread1.start(); // 启动线程1
        thread2.start(); // 启动线程2
    }
}
```

### 13.2 实现`Runnable`接口
实现`run()`方法，将实例传入`Thread`类启动，避免单继承限制。
```java
class MyRunnable implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println(Thread.currentThread().getName() + ": " + i);
        }
    }
}

public class ThreadDemo {
    public static void main(String[] args) {
        MyRunnable runnable = new MyRunnable();
        Thread thread1 = new Thread(runnable, "线程1");
        Thread thread2 = new Thread(runnable, "线程2");
        thread1.start();
        thread2.start();
    }
}
```

### 13.3 实现`Callable`接口（带返回值）
实现`call()`方法，通过`FutureTask`获取返回值，支持异常抛出。
```java
import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;

class MyCallable implements Callable<Integer> {
    @Override
    public Integer call() throws Exception {
        int sum = 0;
        for (int i = 1; i <= 100; i++) {
            sum += i;
        }
        return sum;
    }
}

public class ThreadDemo {
    public static void main(String[] args) throws Exception {
        MyCallable callable = new MyCallable();
        FutureTask<Integer> futureTask = new FutureTask<>(callable);
        Thread thread = new Thread(futureTask);
        thread.start();
        Integer result = futureTask.get(); // 获取返回值，阻塞直到线程完成
        System.out.println("1到100的和：" + result); // 输出：5050
    }
}
```

## 14. Java 自带的四种线程池类型是哪四个？
Java通过`java.util.concurrent.Executors`提供了四种常用线程池，基于`ThreadPoolExecutor`实现，适用于不同场景：

### 14.1 `newFixedThreadPool(int nThreads)`：固定线程池
- 特性：核心线程数=最大线程数=nThreads，无空闲线程（超时时间为0），任务队列无界。
- 适用场景：任务量固定且耗时较长的场景，如服务器端的稳定任务处理。
- 示例：
  ```java
  ExecutorService fixedPool = Executors.newFixedThreadPool(5);
  for (int i = 0; i < 10; i++) {
      fixedPool.execute(() -> System.out.println(Thread.currentThread().getName()));
  }
  fixedPool.shutdown();
  ```

### 14.2 `newCachedThreadPool()`：缓存线程池
- 特性：核心线程数=0，最大线程数=`Integer.MAX_VALUE`，空闲线程超时60秒，任务队列为同步队列。
- 适用场景：短期、轻量级任务，线程可复用，避免频繁创建线程。
- 示例：
  ```java
  ExecutorService cachedPool = Executors.newCachedThreadPool();
  for (int i = 0; i < 20; i++) {
      cachedPool.execute(() -> System.out.println(Thread.currentThread().getName()));
  }
  cachedPool.shutdown();
  ```

### 14.3 `newSingleThreadExecutor()`：单线程池
- 特性：核心线程数=最大线程数=1，任务队列无界，保证任务按顺序执行。
- 适用场景：需要串行执行任务的场景，如日志写入、任务排队处理。
- 示例：
  ```java
  ExecutorService singlePool = Executors.newSingleThreadExecutor();
  for (int i = 0; i < 5; i++) {
      singlePool.execute(() -> System.out.println(Thread.currentThread().getName()));
  }
  singlePool.shutdown();
  ```

### 14.4 `newScheduledThreadPool(int corePoolSize)`：定时线程池
- 特性：核心线程数固定，最大线程数=`Integer.MAX_VALUE`，支持定时/周期性任务。
- 适用场景：定时任务（如心跳检测）、周期性任务（如数据同步）。
- 示例：
  ```java
  ScheduledExecutorService scheduledPool = Executors.newScheduledThreadPool(3);
  // 延迟1秒执行
  scheduledPool.schedule(() -> System.out.println("延迟执行"), 1, TimeUnit.SECONDS);
  // 延迟2秒，每3秒执行一次
  scheduledPool.scheduleAtFixedRate(() -> System.out.println("周期性执行"), 2, 3, TimeUnit.SECONDS);
  // 关闭线程池（需延迟，否则任务未执行）
  // scheduledPool.shutdown();
  ```

**注意**：实际开发中，推荐直接使用`ThreadPoolExecutor`自定义线程池，避免`Executors`的无界队列导致OOM。

## 15. 对线程里的信号量如何理解？
信号量（`Semaphore`）是Java并发包（`java.util.concurrent`）中的同步工具，用于**控制同时访问特定资源的线程数量**，本质是一个计数器，通过`acquire()`和`release()`方法控制资源的获取与释放。

### 15.1 核心原理
1. **初始化**：指定许可数（资源数量），如`Semaphore sem = new Semaphore(3)`表示允许3个线程同时访问资源。
2. **获取许可**：线程调用`acquire()`获取许可，若许可数>0则减1，否则线程阻塞；`acquire(int n)`可获取n个许可。
3. **释放许可**：线程调用`release()`释放许可，许可数加1；`release(int n)`可释放n个许可。
4. **公平性**：支持公平模式（按线程等待顺序获取许可）和非公平模式（默认，可能插队）。

### 15.2 常用方法
| 方法 | 功能 |
|------|------|
| `Semaphore(int permits)` | 创建非公平信号量，指定许可数 |
| `Semaphore(int permits, boolean fair)` | 创建信号量，指定许可数和公平性 |
| `void acquire()` | 获取1个许可，阻塞直到获取成功 |
| `void release()` | 释放1个许可 |
| `int availablePermits()` | 返回当前可用许可数 |

### 15.3 示例：限流器
```java
import java.util.concurrent.Semaphore;

public class SemaphoreDemo {
    private static final Semaphore semaphore = new Semaphore(2); // 允许2个线程同时访问

    public static void main(String[] args) {
        for (int i = 0; i < 5; i++) {
            new Thread(() -> {
                try {
                    semaphore.acquire(); // 获取许可
                    System.out.println(Thread.currentThread().getName() + "访问资源");
                    Thread.sleep(1000); // 模拟资源操作
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    semaphore.release(); // 释放许可
                    System.out.println(Thread.currentThread().getName() + "释放资源");
                }
            }, "线程" + i).start();
        }
    }
}
```

### 15.4 应用场景
- **限流**：控制接口的并发访问数，防止服务过载。
- **资源池**：管理有限的资源（如数据库连接池、线程池）。
- **多任务协作**：协调多个线程完成特定任务，如生产者-消费者模型中控制生产/消费速度。

## 16. 如何按逗号和分号两个符号分割字符串，得到指定数组？
Java中`String.split(String regex)`支持正则表达式，可通过**正则表达式的字符类**`[,;]`匹配逗号和分号，实现按多个符号分割。

### 16.1 基础用法
```java
public class SplitDemo {
    public static void main(String[] args) {
        String str = "a,b;c;d,e";
        // 按逗号或分号分割
        String[] arr = str.split("[,;]");
        for (String s : arr) {
            System.out.println(s); // 输出：a b c d e
        }
    }
}
```

### 16.2 处理空字符串
若字符串中存在连续分隔符，会产生空字符串，可通过`split(regex, limit)`或后续过滤处理。
```java
public class SplitDemo {
    public static void main(String[] args) {
        String str = "a,,b;;c";
        String[] arr = str.split("[,;]");
        System.out.println(Arrays.toString(arr)); // 输出：[a, , b, , c]

        // 过滤空字符串
        String[] nonEmptyArr = Arrays.stream(arr).filter(s -> !s.isEmpty()).toArray(String[]::new);
        System.out.println(Arrays.toString(nonEmptyArr)); // 输出：[a, b, c]
    }
}
```

### 16.3 正则扩展
若需分割的符号更多（如逗号、分号、空格），可扩展字符类：`str.split("[,;\\s]")`（`\\s`匹配空白字符）。

## 17. 如何编写 SSM 框架中的过滤器？
在SSM（Spring + SpringMVC + MyBatis）框架中，过滤器（Filter）用于拦截请求，实现编码处理、登录验证、权限控制等功能，需遵循Servlet规范，步骤如下：

### 17.1 步骤1：实现`Filter`接口
编写过滤器类，实现`javax.servlet.Filter`接口，重写`init()`、`doFilter()`、`destroy()`方法，核心逻辑在`doFilter()`中。

示例：登录验证过滤器
```java
import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;

// 配置过滤路径：所有请求
@WebFilter("/*")
public class LoginFilter implements Filter {

    // 初始化方法，仅执行一次
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        System.out.println("LoginFilter初始化");
    }

    // 过滤核心方法
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        // 转为HTTP请求/响应
        HttpServletRequest req = (HttpServletRequest) request;
        HttpServletResponse resp = (HttpServletResponse) response;

        // 获取请求路径
        String path = req.getRequestURI();
        // 排除登录页、静态资源
        if (path.contains("/login") || path.contains("/static/")) {
            chain.doFilter(request, response); // 放行
            return;
        }

        // 检查session是否有用户
        HttpSession session = req.getSession();
        if (session.getAttribute("user") == null) {
            resp.sendRedirect(req.getContextPath() + "/login"); // 重定向到登录页
            return;
        }

        // 放行，继续执行后续过滤器或Servlet
        chain.doFilter(request, response);
    }

    // 销毁方法，服务器关闭时执行
    @Override
    public void destroy() {
        System.out.println("LoginFilter销毁");
    }
}
```

### 17.2 步骤2：配置过滤器
有两种配置方式：**注解配置**和**XML配置**。
1. **注解配置**：使用`@WebFilter`注解（Servlet 3.0+支持），需在SpringBoot主类或web.xml中开启组件扫描。
2. **XML配置**（web.xml）：
   ```xml
   <filter>
       <filter-name>LoginFilter</filter-name>
       <filter-class>com.filter.LoginFilter</filter-class>
   </filter>
   <filter-mapping>
       <filter-name>LoginFilter</filter-name>
       <url-pattern>/*</url-pattern> <!-- 过滤所有请求 -->
   </filter-mapping>
   ```

### 17.3 步骤3：SSM整合注意事项
1. 过滤器执行在SpringMVC的`DispatcherServlet`之前，无法直接注入Spring Bean，若需使用Spring容器中的对象，可通过`WebApplicationContextUtils`获取：
   ```java
   WebApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(req.getServletContext());
   UserService userService = context.getBean(UserService.class);
   ```
2. 编码过滤器：SSM中常用`CharacterEncodingFilter`处理请求编码，可在web.xml中配置：
   ```xml
   <filter>
       <filter-name>CharacterEncodingFilter</filter-name>
       <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
       <init-param>
           <param-name>encoding</param-name>
           <param-value>UTF-8</param-value>
       </init-param>
       <init-param>
           <param-name>forceEncoding</param-name>
           <param-value>true</param-value>
       </init-param>
   </filter>
   <filter-mapping>
       <filter-name>CharacterEncodingFilter</filter-name>
       <url-pattern>/*</url-pattern>
   </filter-mapping>
   ```

## 18. Java 如何远程调用第三方接口？
Java远程调用第三方接口主要有以下几种方式，适用于不同协议（HTTP/HTTPS、RPC等）：

### 18.1 原生`HttpURLConnection`
JDK自带的HTTP客户端，无需依赖第三方库，适用于简单请求。
```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;

public class HttpUrlConnectionDemo {
    public static void main(String[] args) throws Exception {
        URL url = new URL("https://api.example.com/user");
        HttpURLConnection conn = (HttpURLConnection) url.openConnection();
        conn.setRequestMethod("GET");
        conn.setRequestProperty("Content-Type", "application/json");

        // 获取响应
        BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));
        String line;
        StringBuilder response = new StringBuilder();
        while ((line = reader.readLine()) != null) {
            response.append(line);
        }
        reader.close();
        conn.disconnect();

        System.out.println("响应结果：" + response);
    }
}
```

### 18.2 `HttpClient`（Apache）
Apache的`HttpClient`功能强大，支持HTTPS、连接池、异步请求等，是最常用的方式。
1. **引入依赖**（Maven）：
   ```xml
   <dependency>
       <groupId>org.apache.httpcomponents</groupId>
       <artifactId>httpclient</artifactId>
       <version>4.5.14</version>
   </dependency>
   ```
2. **GET请求示例**：
   ```java
   import org.apache.http.client.methods.CloseableHttpResponse;
   import org.apache.http.client.methods.HttpGet;
   import org.apache.http.impl.client.CloseableHttpClient;
   import org.apache.http.impl.client.HttpClients;
   import org.apache.http.util.EntityUtils;

   public class HttpClientDemo {
       public static void main(String[] args) throws Exception {
           CloseableHttpClient client = HttpClients.createDefault();
           HttpGet get = new HttpGet("https://api.example.com/user");
           CloseableHttpResponse response = client.execute(get);
           String result = EntityUtils.toString(response.getEntity(), "UTF-8");
           System.out.println("响应结果：" + result);
           response.close();
           client.close();
       }
   }
   ```
3. **POST请求示例**（JSON参数）：
   ```java
   import org.apache.http.client.methods.HttpPost;
   import org.apache.http.entity.StringEntity;
   import org.apache.http.impl.client.CloseableHttpClient;
   import org.apache.http.impl.client.HttpClients;
   import org.apache.http.util.EntityUtils;

   public class HttpClientPostDemo {
       public static void main(String[] args) throws Exception {
           CloseableHttpClient client = HttpClients.createDefault();
           HttpPost post = new HttpPost("https://api.example.com/login");
           // 设置JSON参数
           String json = "{\"username\":\"admin\",\"password\":\"123456\"}";
           StringEntity entity = new StringEntity(json, "UTF-8");
           entity.setContentType("application/json");
           post.setEntity(entity);

           CloseableHttpResponse response = client.execute(post);
           String result = EntityUtils.toString(response.getEntity(), "UTF-8");
           System.out.println("响应结果：" + result);
           response.close();
           client.close();
       }
   }
   ```

### 18.3 `RestTemplate`（Spring）
Spring提供的REST客户端，简化HTTP请求，适用于Spring项目。
1. **配置Bean**：
   ```java
   import org.springframework.context.annotation.Bean;
   import org.springframework.context.annotation.Configuration;
   import org.springframework.web.client.RestTemplate;

   @Configuration
   public class RestTemplateConfig {
       @Bean
       public RestTemplate restTemplate() {
           return new RestTemplate();
       }
   }
   ```
2. **使用示例**：
   ```java
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.web.client.RestTemplate;

   public class RestTemplateDemo {
       @Autowired
       private RestTemplate restTemplate;

       public void testGet() {
           String url = "https://api.example.com/user";
           String result = restTemplate.getForObject(url, String.class);
           System.out.println("响应结果：" + result);
       }

       public void testPost() {
           String url = "https://api.example.com/login";
           User user = new User("admin", "123456");
           String result = restTemplate.postForObject(url, user, String.class);
           System.out.println("响应结果：" + result);
       }

       static class User {
           private String username;
           private String password;

           public User(String username, String password) {
               this.username = username;
               this.password = password;
           }

           // getter/setter
       }
   }
   ```

### 18.4 其他方式
- **`OkHttp`**：Square公司的HTTP客户端，性能优异，支持异步请求。
- **RPC框架**：如Dubbo、gRPC，适用于微服务间的高效远程调用（基于TCP协议）。

## 19. Mybatis 里 #{} 和 ${} 的区别及风险是什么？
`#{}`和`${}`是MyBatis中用于参数替换的两种方式，核心区别在于**是否预编译**和**注入风险**。

### 19.1 核心区别
| 特性 | `#{}` | `${}` |
|------|-------|-------|
| **预编译** | 是，参数会被当作字符串处理，自动添加引号 | 否，直接拼接SQL，不添加引号 |
| **参数类型** | 支持任意类型（自动类型转换） | 仅支持字符串类型（需手动处理） |
| **注入风险** | 无，预编译可防止SQL注入 | 有，直接拼接可能导致SQL注入 |
| **适用场景** | 替换SQL中的参数（如`WHERE id = #{id}`） | 替换SQL中的关键字、表名、列名（如`ORDER BY ${column}`） |

### 19.2 示例对比
1. **`#{}`使用**：
   ```xml
   <select id="getUserById" resultType="User">
       SELECT * FROM user WHERE id = #{id}
   </select>
   ```
   实际执行的SQL（预编译）：
   ```sql
   SELECT * FROM user WHERE id = ?
   ```
   参数`id=1`会被替换为`'1'`，自动添加引号。

2. **`${}`使用**：
   ```xml
   <select id="getUserByColumn" resultType="User">
       SELECT * FROM user ORDER BY ${column}
   </select>
   ```
   若参数`column="name"`，实际执行的SQL：
   ```sql
   SELECT * FROM user ORDER BY name
   ```
   直接拼接，无引号。

### 19.3 风险
- **`${}`的SQL注入风险**：若`${}`的参数由用户输入，可能被注入恶意SQL。
  示例：若参数`column="name; DROP TABLE user;"`，执行的SQL会变成：
  ```sql
  SELECT * FROM user ORDER BY name; DROP TABLE user;
  ```
  导致表被删除。
- **`#{}`无注入风险**：因预编译，参数被当作字符串处理，恶意SQL会被转义。

### 19.4 使用建议
- 优先使用`#{}`，适用于大部分参数替换场景。
- 仅在需要动态替换表名、列名、排序关键字时使用`${}`，且需对参数进行严格校验（如白名单过滤）。

## 20. Mybatis 的 XML 对应的 Mapper 接口层方法能否重载？
**MyBatis的Mapper接口方法****不支持重载**，原因如下：
1. **MyBatis通过方法名绑定SQL**：Mapper接口与XML中的SQL通过**方法名**唯一匹配，重载方法的方法名相同，会导致MyBatis无法区分对应的SQL语句，抛出`BindingException`。
2. **示例验证**：
   ```java
   // Mapper接口
   public interface UserMapper {
       User getUserById(int id);
       // 重载方法，方法名相同，参数不同
       User getUserById(int id, String name);
   }
   ```
   XML中定义两个同名SQL：
   ```xml
   <select id="getUserById" resultType="User">
       SELECT * FROM user WHERE id = #{id}
   </select>
   <select id="getUserById" resultType="User">
       SELECT * FROM user WHERE id = #{id} AND name = #{name}
   </select>
   ```
   运行时会抛出`org.apache.ibatis.binding.BindingException: Ambiguous method call`，因为MyBatis无法根据参数区分方法。

**解决方案**：为不同的方法定义不同的方法名，如`getUserById`和`getUserByIdAndName`。

## 21. MyBatis 查询 SQL 时，若不用别名，如何让数据库下划线命名的字段自动匹配 Java 驼峰命名的属性？
MyBatis支持**自动将数据库下划线命名的字段转换为Java驼峰命名的属性**，无需手动写别名，只需开启**驼峰命名自动转换**配置，有两种配置方式：

### 21.1 配置文件方式（mybatis-config.xml）
在MyBatis的核心配置文件中添加`settings`配置：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <settings>
        <!-- 开启驼峰命名自动转换：user_name → userName -->
        <setting name="mapUnderscoreToCamelCase" value="true"/>
    </settings>
    <!-- 其他配置（环境、映射器等） -->
</configuration>
```

### 21.2 SpringBoot 配置方式（application.yml/application.properties）
在SpringBoot项目中，直接在配置文件中添加配置：
1. **application.yml**：
   ```yaml
   mybatis:
     configuration:
       map-underscore-to-camel-case: true # 开启驼峰转换
     mapper-locations: classpath:mapper/*.xml # 映射文件路径
     type-aliases-package: com.entity # 实体类别名包
   ```
2. **application.properties**：
   ```properties
   mybatis.configuration.map-underscore-to-camel-case=true
   mybatis.mapper-locations=classpath:mapper/*.xml
   mybatis.type-aliases-package=com.entity
   ```

### 21.3 原理与示例
- **原理**：开启配置后，MyBatis会将数据库字段名中的下划线去掉，然后将下划线后的第一个字母大写，实现`user_name` → `userName`的转换。
- **示例**：
  数据库表`user`有字段`user_id`、`user_name`，Java实体类`User`有属性`userId`、`userName`。
  SQL查询无需别名：
  ```xml
  <select id="getUserById" resultType="User">
      SELECT user_id, user_name FROM user WHERE user_id = #{id}
  </select>
  ```
  MyBatis会自动将`user_id`映射到`userId`，`user_name`映射到`userName`。

## 22. Spring Boot 项目中同时使用 MySQL 和 Oracle 两个数据库的配置及使用方法是什么？
Spring Boot项目中配置多数据源（MySQL + Oracle）需**配置多个数据源**、**指定不同的Mapper扫描路径**、**配置不同的SqlSessionFactory**，步骤如下：

### 22.1 步骤1：引入依赖（pom.xml）
```xml
<!-- MySQL驱动 -->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <scope>runtime</scope>
</dependency>
<!-- Oracle驱动 -->
<dependency>
    <groupId>com.oracle.database.jdbc</groupId>
    <artifactId>ojdbc8</artifactId>
    <version>21.3.0.0</version>
</dependency>
<!-- MyBatis整合Spring Boot -->
<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
    <version>2.3.0</version>
</dependency>
<!-- 数据库连接池 -->
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid-spring-boot-starter</artifactId>
    <version>1.2.16</version>
</dependency>
```

### 22.2 步骤2：配置多数据源（application.yml）
```yaml
spring:
  datasource:
    # MySQL数据源
    mysql:
      driver-class-name: com.mysql.cj.jdbc.Driver
      url: jdbc:mysql://localhost:3306/test_mysql?useUnicode=true&characterEncoding=utf8&serverTimezone=Asia/Shanghai
      username: root
      password: root
      type: com.alibaba.druid.pool.DruidDataSource
    # Oracle数据源
    oracle:
      driver-class-name: oracle.jdbc.driver.OracleDriver
      url: jdbc:oracle:thin:@localhost:1521:ORCL
      username: scott
      password: tiger
      type: com.alibaba.druid.pool.DruidDataSource

# MyBatis配置
mybatis:
  configuration:
    map-underscore-to-camel-case: true
  # 可配置公共的别名包
  type-aliases-package: com.entity
```

### 22.3 步骤3：配置数据源和SqlSessionFactory
分别配置MySQL和Oracle的数据源、`SqlSessionFactory`、`SqlSessionTemplate`，指定不同的Mapper扫描路径。

#### 3.1 MySQL数据源配置
```java
import com.alibaba.druid.pool.DruidDataSource;
import org.apache.ibatis.session.SqlSessionFactory;
import org.mybatis.spring.SqlSessionFactoryBean;
import org.mybatis.spring.SqlSessionTemplate;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;

import javax.sql.DataSource;

@Configuration
// 扫描MySQL的Mapper接口，指定sqlSessionFactoryRef
@MapperScan(basePackages = "com.mapper.mysql", sqlSessionFactoryRef = "mysqlSqlSessionFactory")
public class MysqlDataSourceConfig {

    // 配置MySQL数据源
    @Bean(name = "mysqlDataSource")
    @Primary // 主数据源，必须指定一个主数据源
    @ConfigurationProperties(prefix = "spring.datasource.mysql")
    public DataSource mysqlDataSource() {
        return new DruidDataSource();
    }

    // 配置MySQL的SqlSessionFactory
    @Bean(name = "mysqlSqlSessionFactory")
    @Primary
    public SqlSessionFactory mysqlSqlSessionFactory(@Qualifier("mysqlDataSource") DataSource dataSource) throws Exception {
        SqlSessionFactoryBean bean = new SqlSessionFactoryBean();
        bean.setDataSource(dataSource);
        // 指定MySQL的Mapper.xml路径
        bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources("classpath:mapper/mysql/*.xml"));
        return bean.getObject();
    }

    // 配置MySQL的SqlSessionTemplate
    @Bean(name = "mysqlSqlSessionTemplate")
    @Primary
    public SqlSessionTemplate mysqlSqlSessionTemplate(@Qualifier("mysqlSqlSessionFactory") SqlSessionFactory sqlSessionFactory) {
        return new SqlSessionTemplate(sqlSessionFactory);
    }
}
```

#### 3.2 Oracle数据源配置
```java
import com.alibaba.druid.pool.DruidDataSource;
import org.apache.ibatis.session.SqlSessionFactory;
import org.mybatis.spring.SqlSessionFactoryBean;
import org.mybatis.spring.SqlSessionTemplate;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;

import javax.sql.DataSource;

@Configuration
// 扫描Oracle的Mapper接口
@MapperScan(basePackages = "com.mapper.oracle", sqlSessionFactoryRef = "oracleSqlSessionFactory")
public class OracleDataSourceConfig {

    // 配置Oracle数据源
    @Bean(name = "oracleDataSource")
    @ConfigurationProperties(prefix = "spring.datasource.oracle")
    public DataSource oracleDataSource() {
        return new DruidDataSource();
    }

    // 配置Oracle的SqlSessionFactory
    @Bean(name = "oracleSqlSessionFactory")
    public SqlSessionFactory oracleSqlSessionFactory(@Qualifier("oracleDataSource") DataSource dataSource) throws Exception {
        SqlSessionFactoryBean bean = new SqlSessionFactoryBean();
        bean.setDataSource(dataSource);
        // 指定Oracle的Mapper.xml路径
        bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources("classpath:mapper/oracle/*.xml"));
        return bean.getObject();
    }

    // 配置Oracle的SqlSessionTemplate
    @Bean(name = "oracleSqlSessionTemplate")
    public SqlSessionTemplate oracleSqlSessionTemplate(@Qualifier("oracleSqlSessionFactory") SqlSessionFactory sqlSessionFactory) {
        return new SqlSessionTemplate(sqlSessionFactory);
    }
}
```

### 22.4 步骤4：编写Mapper和XML
1. **MySQL Mapper**：放在`com.mapper.mysql`包下，XML放在`resources/mapper/mysql`下。
   ```java
   package com.mapper.mysql;

   import com.entity.UserMysql;
   import org.apache.ibatis.annotations.Select;

   public interface UserMysqlMapper {
       @Select("SELECT * FROM user WHERE id = #{id}")
       UserMysql getUserById(int id);
   }
   ```
2. **Oracle Mapper**：放在`com.mapper.oracle`包下，XML放在`resources/mapper/oracle`下。
   ```java
   package com.mapper.oracle;

   import com.entity.UserOracle;
   import org.apache.ibatis.annotations.Select;

   public interface UserOracleMapper {
       @Select("SELECT * FROM emp WHERE empno = #{id}")
       UserOracle getEmpById(int id);
   }
   ```

### 22.5 步骤5：使用多数据源
在Service中注入不同的Mapper，即可操作对应数据库。
```java
import com.entity.UserMysql;
import com.entity.UserOracle;
import com.mapper.mysql.UserMysqlMapper;
import com.mapper.oracle.UserOracleMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class UserService {

    @Autowired
    private UserMysqlMapper userMysqlMapper;

    @Autowired
    private UserOracleMapper userOracleMapper;

    public UserMysql getMysqlUser(int id) {
        return userMysqlMapper.getUserById(id);
    }

    public UserOracle getOracleEmp(int id) {
        return userOracleMapper.getEmpById(id);
    }
}
```

## 23. MySQL 分页查询语句怎么写？
MySQL中分页查询主要使用**`LIMIT`关键字**，语法灵活，支持基础分页和偏移量分页，核心语法：
```sql
SELECT 列名 FROM 表名 [WHERE 条件] [ORDER BY 列名] LIMIT [偏移量,] 条数;
```
- **偏移量**：可选，指从第几条记录开始（从0开始计数），默认从0开始。
- **条数**：必选，指查询的记录数。

### 23.1 基础分页（无偏移量）
查询前N条记录，省略偏移量（默认从0开始）。
```sql
-- 查询user表中前10条记录
SELECT * FROM user LIMIT 10;
```

### 23.2 偏移量分页
查询从指定位置开始的N条记录，适用于分页展示（如第2页、第3页）。
```sql
-- 查询user表中从第10条开始的5条记录（第11-15条）
SELECT * FROM user LIMIT 10, 5;
```

### 23.3 结合排序的分页
分页前通常先排序，避免数据顺序混乱。
```sql
-- 按id降序，查询user表中从第20条开始的10条记录
SELECT * FROM user ORDER BY id DESC LIMIT 20, 10;
```

### 23.4 优化大偏移量分页
当偏移量很大时（如`LIMIT 100000, 10`），MySQL需要扫描大量记录，性能较低，可通过**主键/索引排序**优化：
```sql
-- 优化前：大偏移量，性能差
SELECT * FROM user LIMIT 100000, 10;

-- 优化后：通过主键定位，减少扫描
SELECT * FROM user WHERE id > 100000 ORDER BY id LIMIT 10;
```

## 24. MySQL 分页中，每页 10 条数据，查询第三页的 limit 后两个参数是什么？
查询第三页的`LIMIT`参数计算规则：
- **偏移量** = (页码 - 1) × 每页条数
- **条数** = 每页条数

已知每页10条，第三页的参数：
- 偏移量 = (3 - 1) × 10 = 20
- 条数 = 10

因此，`LIMIT`后的两个参数为**20和10**，SQL语句：
```sql
SELECT * FROM 表名 LIMIT 20, 10;
```
该语句表示从第20条记录开始（从0计数），查询10条记录，即第三页的内容。

## 25. 分组聚合函数有哪些？
分组聚合函数用于对数据分组后进行统计计算，常与`GROUP BY`子句配合使用，MySQL中常用的分组聚合函数如下：

### 25.1 基础统计函数
| 函数 | 功能 | 示例 |
|------|------|------|
| `COUNT()` | 统计记录数，`COUNT(*)`统计所有行，`COUNT(列名)`统计非NULL值 | `SELECT COUNT(*) FROM user GROUP BY age;` |
| `SUM()` | 计算数值列的总和，忽略NULL值 | `SELECT SUM(salary) FROM emp GROUP BY deptno;` |
| `AVG()` | 计算数值列的平均值，忽略NULL值 | `SELECT AVG(score) FROM student GROUP BY class_id;` |
| `MAX()` | 求列的最大值，支持数值、字符串、日期 | `SELECT MAX(age) FROM user GROUP BY gender;` |
| `MIN()` | 求列的最小值，支持数值、字符串、日期 | `SELECT MIN(salary) FROM emp GROUP BY deptno;` |

### 25.2 高级聚合函数
| 函数 | 功能 | 示例 |
|------|------|------|
| `GROUP_CONCAT()` | 将分组后的列值拼接为字符串，默认用逗号分隔 | `SELECT GROUP_CONCAT(name) FROM user GROUP BY age;` |
| `STDDEV()` | 计算数值列的标准差 | `SELECT STDDEV(score) FROM student GROUP BY class_id;` |
| `VARIANCE()` | 计算数值列的方差 | `SELECT VARIANCE(salary) FROM emp GROUP BY deptno;` |

### 25.3 示例：组合使用聚合函数
```sql
-- 按部门分组，统计每个部门的员工数、平均工资、最高工资、最低工资
SELECT 
    deptno,
    COUNT(*) AS emp_count,
    AVG(salary) AS avg_salary,
    MAX(salary) AS max_salary,
    MIN(salary) AS min_salary
FROM emp
GROUP BY deptno;
```

## 26. 两个结构相同的表（3 列 5 行），如何查询合并为 3 列 10 行的结果集？如何合并为 3 列 4 行的结果集？
假设两个表为`t1`和`t2`，结构相同（如`id`、`name`、`age`三列），分别有5行数据，根据需求不同，使用**`UNION`/`UNION ALL`**或**`JOIN`**实现合并。

### 26.1 合并为3列10行（行合并）
使用**`UNION ALL`**（保留重复行）或**`UNION`**（去重）将两个表的行合并，适用于纵向拼接。
1. **`UNION ALL`**：保留所有行，包括重复行，效率更高。
   ```sql
   -- 合并t1和t2的所有行，共10行
   SELECT id, name, age FROM t1
   UNION ALL
   SELECT id, name, age FROM t2;
   ```
2. **`UNION`**：去除重复行，若两个表有重复数据，结果行数可能小于10。
   ```sql
   -- 合并并去重
   SELECT id, name, age FROM t1
   UNION
   SELECT id, name, age FROM t2;
   ```

### 26.2 合并为3列4行（列合并后筛选）
需通过**连接（JOIN）**结合筛选条件实现，核心思路：将两个表按关联字段连接，再筛选出4行数据。
假设`t1`和`t2`通过`id`关联，示例：
1. **内连接（INNER JOIN）**：取两表`id`相同的行，筛选出4行。
   ```sql
   -- 按id内连接，取前4行
   SELECT t1.id, t1.name, t1.age
   FROM t1
   INNER JOIN t2 ON t1.id = t2.id
   LIMIT 4;
   ```
2. **条件筛选**：若需指定行，可通过`WHERE`条件过滤。
   ```sql
   -- 合并后筛选id<5的行，共4行
   SELECT id, name, age FROM t1
   UNION ALL
   SELECT id, name, age FROM t2
   WHERE id < 5;
   ```

## 27. 数据库中 VARCHAR、INT、BLOB、CLOB 字段的用途分别是什么？
数据库中不同数据类型适用于存储不同类型的数据，`VARCHAR`、`INT`、`BLOB`、`CLOB`是常用类型，用途如下：

### 27.1 `VARCHAR`：可变长度字符串类型
- **用途**：存储短文本数据，如姓名、地址、手机号、邮箱等。
- **特点**：
    - 可变长度，占用空间为实际字符数 + 1/2字节（长度标识），节省空间。
    - 有长度限制（如MySQL中`VARCHAR(255)`表示最大255个字符）。
    - 支持索引，查询效率高。
- **示例**：`name VARCHAR(50)`、`phone VARCHAR(11)`。

### 27.2 `INT`：整数类型
- **用途**：存储整数数据，如年龄、数量、ID、编号等。
- **特点**：
    - 占用4字节（MySQL中），取值范围为`-2^31`到`2^31-1`（-2147483648到2147483647）。
    - 支持自增（`AUTO_INCREMENT`），常用于主键。
    - 计算和查询效率极高。
- **扩展**：`TINYINT`（1字节）、`SMALLINT`（2字节）、`BIGINT`（8字节）等，适用于不同数值范围。
- **示例**：`id INT PRIMARY KEY AUTO_INCREMENT`、`age INT`。

### 27.3 `BLOB`：二进制大对象类型
- **用途**：存储二进制数据，如图片、音频、视频、文件等。
- **特点**：
    - 按存储容量分为`TINYBLOB`、`BLOB`、`MEDIUMBLOB`、`LONGBLOB`（MySQL）。
    - 存储的是二进制流，无法直接查询内容，需通过程序解析。
    - 占用空间大，查询效率低，不建议频繁查询。
- **示例**：`avatar BLOB`（存储用户头像）、`file_data LONGBLOB`（存储文件）。

### 27.4 `CLOB`：字符大对象类型
- **用途**：存储大文本数据，如文章内容、日志、富文本等。
- **特点**：
    - 按存储容量分为`TINYCLOB`、`CLOB`、`MEDIUMCLOB`、`LONGCLOB`（MySQL中对应`TEXT`、`MEDIUMTEXT`、`LONGTEXT`）。
    - 存储的是字符数据，支持文本查询和索引（部分数据库）。
    - 适用于超过`VARCHAR`长度限制的文本。
- **示例**：`content LONGTEXT`（存储文章内容）、`log_text MEDIUMTEXT`（存储系统日志）。

## 28. 在控制台打印九九乘法表，两个 for 循环的起始和结束条件是什么？
九九乘法表的打印核心是**双层for循环**：
- **外层循环**：控制行数（1-9行），起始为1，结束为9。
- **内层循环**：控制每行的列数，列数不超过当前行数，起始为1，结束为当前行数。

### 28.1 代码实现
```java
public class MultiplicationTable {
    public static void main(String[] args) {
        // 外层循环：控制行数，i从1到9
        for (int i = 1; i <= 9; i++) {
            // 内层循环：控制列数，j从1到i（列数≤行数）
            for (int j = 1; j <= i; j++) {
                System.out.print(j + "×" + i + "=" + (i * j) + "\t");
            }
            System.out.println(); // 换行
        }
    }
}
```

### 28.2 循环条件说明
1. **外层循环（i）**：
    - 起始条件：`i = 1`（第一行）。
    - 结束条件：`i <= 9`（第九行，九九乘法表共9行）。
2. **内层循环（j）**：
    - 起始条件：`j = 1`（每行的第一个式子）。
    - 结束条件：`j <= i`（每行的式子数等于行数，如第5行有5个式子）。

### 28.3 输出结果
```
1×1=1	
1×2=2	2×2=4	
1×3=3	2×3=6	3×3=9	
1×4=4	2×4=8	3×4=12	4×4=16	
1×5=5	2×5=10	3×5=15	4×5=20	5×5=25	
1×6=6	2×6=12	3×6=18	4×6=24	5×6=30	6×6=36	
1×7=7	2×7=14	3×7=21	4×7=28	5×7=35	6×7=42	7×7=49	
1×8=8	2×8=16	3×8=24	4×8=32	5×8=40	6×8=48	7×8=56	8×8=64	
1×9=9	2×9=18	3×9=27	4×9=36	5×9=45	6×9=54	7×9=63	8×9=72	9×9=81	
```

## 29. 如何封装一个方法求两个 int 类型整数的最大公约数？
最大公约数（GCD，Greatest Common Divisor）是两个数的最大公共因数，常用**欧几里得算法（辗转相除法）**实现，步骤为：用较大数除以较小数，再用余数去除除数，直到余数为0，最后的除数即为最大公约数。

### 29.1 方法封装（欧几里得算法）
```java
public class GCDUtil {
    /**
     * 求两个int整数的最大公约数
     * @param a 第一个整数
     * @param b 第二个整数
     * @return 最大公约数
     */
    public static int getGCD(int a, int b) {
        // 处理负数：取绝对值
        a = Math.abs(a);
        b = Math.abs(b);
        // 辗转相除法：当b不为0时，循环计算余数
        while (b != 0) {
            int temp = a % b;
            a = b;
            b = temp;
        }
        return a;
    }

    // 测试
    public static void main(String[] args) {
        System.out.println(getGCD(12, 18)); // 输出：6
        System.out.println(getGCD(25, 15)); // 输出：5
        System.out.println(getGCD(-8, 12)); // 输出：4（处理负数）
        System.out.println(getGCD(7, 13)); // 输出：1（互质）
    }
}
```

### 29.2 递归实现
也可通过递归实现欧几里得算法，代码更简洁：
```java
public static int getGCDRecursive(int a, int b) {
    a = Math.abs(a);
    b = Math.abs(b);
    if (b == 0) {
        return a;
    }
    return getGCDRecursive(b, a % b);
}
```

### 29.3 原理说明
以`12`和`18`为例：
1. `18 % 12 = 6` → 除数变为12，余数变为6。
2. `12 % 6 = 0` → 余数为0，最后的除数6即为最大公约数。

## 30. 青蛙跳 100 阶台阶，每次最多跳 4 阶，从第 1 阶跳到第 100 阶有多少种跳法？
该问题属于**动态规划**经典问题，类似斐波那契数列的扩展，核心思路是：到达第`n`阶的跳法数等于到达第`n-1`、`n-2`、`n-3`、`n-4`阶的跳法数之和（因为每次最多跳4阶）。

### 30.1 动态规划分析
1. **状态定义**：设`dp[n]`为跳到第`n`阶的跳法数。
2. **状态转移方程**：
    - 当`n ≤ 4`时，`dp[n]`为2^(n-1)（如`n=1`时1种，`n=2`时2种，`n=3`时4种，`n=4`时8种）。
    - 当`n > 4`时，`dp[n] = dp[n-1] + dp[n-2] + dp[n-3] + dp[n-4]`（最后一步可跳1、2、3、4阶）。
3. **初始条件**：
    - `dp[1] = 1`（仅1种：跳1阶）。
    - `dp[2